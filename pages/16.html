<HEAD>


<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.08">
<STYLE type="text/css">
.toc{list-style:none;}
.title{margin:auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
.part{margin:auto;text-align:center}
</STYLE>
</HEAD>

<BODY >
<!--HEVEA command line is: hevea -fix FAQ.v.tex -->
<!--HTMLHEAD-->
<!--ENDHTML-->
<!--PREFIX <ARG ></ARG>-->
<!--CUT DEF section 1 -->




<BR>
<BR>


<TABLE CLASS="title">
<TR><TD></TD>
</TR></TABLE>
<BLOCKQUOTE CLASS="abstract"><B>Abstract: </B>
This note intends to provide an easy way to get acquainted with the
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> theorem prover. It tries to formulate appropriate answers
to some of the questions any newcomers will face, and to give
pointers to other references when possible.
</BLOCKQUOTE>
<!--TOC section Contents-->

<H2 CLASS="section">Contents</H2><!--SEC END -->

<UL CLASS="toc"><LI CLASS="li-toc">
<a name="sum1"><A HREF="#htoc1">1&nbsp;&nbsp;Introduction</A></a>
<LI CLASS="li-toc"><a name="sum2"><A HREF="#htoc2">2&nbsp;&nbsp;Presentation</A></a>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc3">1&nbsp;&nbsp;What is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc4">2&nbsp;&nbsp;Did you really need to name it like that?</A>
<LI CLASS="li-toc"><A HREF="#htoc5">3&nbsp;&nbsp;Is <SPAN STYLE="font-variant:small-caps">Coq</SPAN> a theorem prover?</A>
<LI CLASS="li-toc"><A HREF="#htoc6">4&nbsp;&nbsp;What are the other theorem provers?</A>
<LI CLASS="li-toc"><A HREF="#htoc7">5&nbsp;&nbsp;What do I have to trust when I see a proof checked by Coq?</A>
<LI CLASS="li-toc"><A HREF="#htoc8">6&nbsp;&nbsp;Where can I find information about the theory behind <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc9">7&nbsp;&nbsp;How can I use <SPAN STYLE="font-variant:small-caps">Coq</SPAN> to prove programs?</A>
<LI CLASS="li-toc"><A HREF="#htoc10">8&nbsp;&nbsp;How old is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc11">9&nbsp;&nbsp;What are the <SPAN STYLE="font-variant:small-caps">Coq</SPAN>-related tools?</A>
<LI CLASS="li-toc"><A HREF="#htoc12">10&nbsp;&nbsp;What are the high-level tactics of <SPAN STYLE="font-variant:small-caps">Coq</SPAN></A>
<LI CLASS="li-toc"><A HREF="#htoc13">11&nbsp;&nbsp;What are the main libraries available for <SPAN STYLE="font-variant:small-caps">Coq</SPAN></A>
<LI CLASS="li-toc"><A HREF="#htoc14">12&nbsp;&nbsp;What are the mathematical applications for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc15">13&nbsp;&nbsp;What are the industrial applications for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</UL>
</UL>
<LI CLASS="li-toc"><a name="sum3"><A HREF="#htoc16">3&nbsp;&nbsp;Documentation</A></a>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc17">14&nbsp;&nbsp;Where can I find documentation about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc18">15&nbsp;&nbsp;Where can I find this FAQ on the web?</A>
<LI CLASS="li-toc"><A HREF="#htoc19">16&nbsp;&nbsp;How can I submit suggestions / improvements / additions for this FAQ?</A>
<LI CLASS="li-toc"><A HREF="#htoc20">17&nbsp;&nbsp;Is there any mailing list about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc21">18&nbsp;&nbsp;Where can I find an archive of the list?</A>
<LI CLASS="li-toc"><A HREF="#htoc22">19&nbsp;&nbsp;How can I be kept informed of new releases of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc23">20&nbsp;&nbsp;Is there any book about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc24">21&nbsp;&nbsp;Where can I find some <SPAN STYLE="font-variant:small-caps">Coq</SPAN> examples?</A>
<LI CLASS="li-toc"><A HREF="#htoc25">22&nbsp;&nbsp;How can I report a bug?</A>
</UL>
</UL>
<LI CLASS="li-toc"><a name="sum4"><A HREF="#htoc26">4&nbsp;&nbsp;Installation</A></a>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc27">23&nbsp;&nbsp;What is the license of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc28">24&nbsp;&nbsp;Where can I find the sources of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc29">25&nbsp;&nbsp;On which platform is <SPAN STYLE="font-variant:small-caps">Coq</SPAN> available?</A>
</UL>
</UL>
<LI CLASS="li-toc"><a name="sum5"><A HREF="#htoc30">5&nbsp;&nbsp;The logic of <SPAN STYLE="font-variant:small-caps">Coq</SPAN></A></a>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc31">5.1&nbsp;&nbsp;General</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc32">26&nbsp;&nbsp;What is the logic of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc33">27&nbsp;&nbsp;Is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s logic intuitionistic or classical?</A>
<LI CLASS="li-toc"><A HREF="#htoc34">28&nbsp;&nbsp;Can I define non-terminating programs in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc35">29&nbsp;&nbsp;How is equational reasoning working in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc36">5.2&nbsp;&nbsp;Axioms</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc37">30&nbsp;&nbsp;What axioms can be safely added to <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc38">31&nbsp;&nbsp;What standard axioms are inconsistent with <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc39">32&nbsp;&nbsp;What is Streicher's axiom <I>K</I></A>
<LI CLASS="li-toc"><A HREF="#htoc40">33&nbsp;&nbsp;What is proof-irrelevance</A>
<LI CLASS="li-toc"><A HREF="#htoc41">34&nbsp;&nbsp;What about functional extensionality?</A>
<LI CLASS="li-toc"><A HREF="#htoc42">35&nbsp;&nbsp;Is <TT>Prop</TT> impredicative?</A>
<LI CLASS="li-toc"><A HREF="#htoc43">36&nbsp;&nbsp;Is <TT>Set</TT> impredicative?</A>
<LI CLASS="li-toc"><A HREF="#htoc44">37&nbsp;&nbsp;Is <TT>Type</TT> impredicative?</A>
<LI CLASS="li-toc"><A HREF="#htoc45">38&nbsp;&nbsp;I have two proofs of the same proposition. Can I prove they are equal?</A>
<LI CLASS="li-toc"><A HREF="#htoc46">39&nbsp;&nbsp;I have two proofs of an equality statement. Can I prove they are 
equal?</A>
<LI CLASS="li-toc"><A HREF="#htoc47">40&nbsp;&nbsp;Can I prove that the second components of equal dependent
pairs are equal?</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc48">5.3&nbsp;&nbsp;Impredicativity</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc49">41&nbsp;&nbsp;Why <TT>injection</TT> does not work on impredicative <TT>Set</TT>?</A>
<LI CLASS="li-toc"><A HREF="#htoc50">42&nbsp;&nbsp;What is a &#8220;large inductive definition&#8221;?</A>
</UL>
</UL>
<LI CLASS="li-toc"><a name="sum6"><A HREF="#htoc51">6&nbsp;&nbsp;Talkin' with the Rooster</A></a>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc52">6.1&nbsp;&nbsp;My goal is ..., how can I prove it?</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc53">43&nbsp;&nbsp;My goal is a conjunction, how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc54">44&nbsp;&nbsp;My goal contains a conjunction as an hypothesis, how can I use it?</A>
<LI CLASS="li-toc"><A HREF="#htoc55">45&nbsp;&nbsp;My goal is a disjunction, how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc56">46&nbsp;&nbsp;My goal is an universally quantified statement, how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc57">47&nbsp;&nbsp;My goal is an existential, how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc58">48&nbsp;&nbsp;My goal is solvable by some lemma, how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc59">49&nbsp;&nbsp;My goal contains False as an hypothesis, how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc60">50&nbsp;&nbsp;My goal is an equality of two convertible terms, how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc61">51&nbsp;&nbsp;My goal is a <TT>let x := a in ...</TT>, how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc62">52&nbsp;&nbsp;My goal is a <TT>let (a, ..., b) := c in</TT>, how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc63">53&nbsp;&nbsp;My goal contains some existential hypotheses, how can I use it?</A>
<LI CLASS="li-toc"><A HREF="#htoc64">54&nbsp;&nbsp;My goal contains some existential hypotheses, how can I use it and decompose my knowledge about this new thing into different hypotheses?</A>
<LI CLASS="li-toc"><A HREF="#htoc65">55&nbsp;&nbsp;My goal is an equality, how can I swap the left and right hand terms?</A>
<LI CLASS="li-toc"><A HREF="#htoc66">56&nbsp;&nbsp;My hypothesis is an equality, how can I swap the left and right hand terms?</A>
<LI CLASS="li-toc"><A HREF="#htoc67">57&nbsp;&nbsp;My goal is an equality, how can I prove it by transitivity?</A>
<LI CLASS="li-toc"><A HREF="#htoc68">58&nbsp;&nbsp;My goal would be solvable using <TT>apply;assumption</TT> if it would not create meta-variables, how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc69">59&nbsp;&nbsp;My goal is solvable by some lemma within a set of lemmas and I don't want to remember which one, how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc70">60&nbsp;&nbsp;My goal is one of the hypotheses, how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc71">61&nbsp;&nbsp;My goal appears twice in the hypotheses and I want to choose which one is used, how can I do it?</A>
<LI CLASS="li-toc"><A HREF="#htoc72">62&nbsp;&nbsp;What can be the difference between applying one hypothesis or another in the context of the last question?</A>
<LI CLASS="li-toc"><A HREF="#htoc73">63&nbsp;&nbsp;My goal is a propositional tautology, how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc74">64&nbsp;&nbsp;My goal is a first order formula, how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc75">65&nbsp;&nbsp;My goal is solvable by a sequence of rewrites, how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc76">66&nbsp;&nbsp;My goal is a disequality solvable by a sequence of rewrites, how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc77">67&nbsp;&nbsp;My goal is an equality on some ring (e.g. natural numbers), how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc78">68&nbsp;&nbsp;My goal is an equality on some field (e.g. real numbers), how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc79">69&nbsp;&nbsp;My goal is an inequality on integers in Presburger's arithmetic (an expression build from +,-,constants and variables), how can I prove it?</A>
<LI CLASS="li-toc"><A HREF="#htoc80">70&nbsp;&nbsp;My goal is an equation solvable using equational hypothesis on some ring (e.g. natural numbers), how can I prove it?</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc81">6.2&nbsp;&nbsp;Tactics usage</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc82">71&nbsp;&nbsp;I want to state a fact that I will use later as an hypothesis, how can I do it?</A>
<LI CLASS="li-toc"><A HREF="#htoc83">72&nbsp;&nbsp;I want to state a fact that I will use later as an hypothesis and prove it later, how can I do it?</A>
<LI CLASS="li-toc"><A HREF="#htoc84">73&nbsp;&nbsp;What is the difference between <TT>Qed</TT> and <TT>Defined</TT>?</A>
<LI CLASS="li-toc"><A HREF="#htoc85">74&nbsp;&nbsp;How can I know what a tactic does?</A>
<LI CLASS="li-toc"><A HREF="#htoc86">75&nbsp;&nbsp;Why <TT>auto</TT> does not work? How can I fix it?</A>
<LI CLASS="li-toc"><A HREF="#htoc87">76&nbsp;&nbsp;What is <TT>eauto</TT>?</A>
<LI CLASS="li-toc"><A HREF="#htoc88">77&nbsp;&nbsp;How can I speed up <TT>auto</TT>?</A>
<LI CLASS="li-toc"><A HREF="#htoc89">78&nbsp;&nbsp;What is the equivalent of <TT>tauto</TT> for classical logic?</A>
<LI CLASS="li-toc"><A HREF="#htoc90">79&nbsp;&nbsp;I want to replace some term with another in the goal, how can I do it?</A>
<LI CLASS="li-toc"><A HREF="#htoc91">80&nbsp;&nbsp;I want to replace some term with another in an hypothesis, how can I do it?</A>
<LI CLASS="li-toc"><A HREF="#htoc92">81&nbsp;&nbsp;I want to replace some symbol with its definition, how can I do it?</A>
<LI CLASS="li-toc"><A HREF="#htoc93">82&nbsp;&nbsp;How can I reduce some term?</A>
<LI CLASS="li-toc"><A HREF="#htoc94">83&nbsp;&nbsp;How can I declare a shortcut for some term?</A>
<LI CLASS="li-toc"><A HREF="#htoc95">84&nbsp;&nbsp;How can I perform case analysis?</A>
<LI CLASS="li-toc"><A HREF="#htoc96">85&nbsp;&nbsp;Why should I name my intros?</A>
<LI CLASS="li-toc"><A HREF="#htoc97">86&nbsp;&nbsp;How can I automatize the naming?</A>
<LI CLASS="li-toc"><A HREF="#htoc98">87&nbsp;&nbsp;I want to automatize the use of some tactic, how can I do it?</A>
<LI CLASS="li-toc"><A HREF="#htoc99">88&nbsp;&nbsp;I want to execute the <TT>p</TT>roof with tactic only if it solves the goal, how can I do it?</A>
<LI CLASS="li-toc"><A HREF="#htoc100">89&nbsp;&nbsp;How can I do the opposite of the <TT>intro</TT> tactic?</A>
<LI CLASS="li-toc"><A HREF="#htoc101">90&nbsp;&nbsp;One of the hypothesis is an equality between a variable and some term, I want to get rid of this variable, how can I do it?</A>
<LI CLASS="li-toc"><A HREF="#htoc102">91&nbsp;&nbsp;What can I do if I get &#8220;<TT>generated subgoal term has metavariables in it </TT>&#8221;?</A>
<LI CLASS="li-toc"><A HREF="#htoc103">92&nbsp;&nbsp;How can I instantiate some metavariable?</A>
<LI CLASS="li-toc"><A HREF="#htoc104">93&nbsp;&nbsp;What is the use of the <TT>pattern</TT> tactic?</A>
<LI CLASS="li-toc"><A HREF="#htoc105">94&nbsp;&nbsp;What is the difference between assert, cut and generalize?</A>
<LI CLASS="li-toc"><A HREF="#htoc106">95&nbsp;&nbsp;What can I do if <SPAN STYLE="font-variant:small-caps">Coq</SPAN>can not infer some implicit argument ?</A>
<LI CLASS="li-toc"><A HREF="#htoc107">96&nbsp;&nbsp;How can I explicit some implicit argument ?</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc108">6.3&nbsp;&nbsp;Proof management</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc109">97&nbsp;&nbsp;How can I change the order of the subgoals?</A>
<LI CLASS="li-toc"><A HREF="#htoc110">98&nbsp;&nbsp;How can I change the order of the hypothesis?</A>
<LI CLASS="li-toc"><A HREF="#htoc111">99&nbsp;&nbsp;How can I change the name of an hypothesis?</A>
<LI CLASS="li-toc"><A HREF="#htoc112">100&nbsp;&nbsp;How can I delete some hypothesis?</A>
<LI CLASS="li-toc"><A HREF="#htoc113">101&nbsp;&nbsp;How can use a proof which is not finished?</A>
<LI CLASS="li-toc"><A HREF="#htoc114">102&nbsp;&nbsp;How can I state a conjecture?</A>
<LI CLASS="li-toc"><A HREF="#htoc115">103&nbsp;&nbsp;What is the difference between a lemma, a fact and a theorem?</A>
<LI CLASS="li-toc"><A HREF="#htoc116">104&nbsp;&nbsp;How can I organize my proofs?</A>
</UL>
</UL>
<LI CLASS="li-toc"><a name="sum7"><A HREF="#htoc117">7&nbsp;&nbsp;Inductive and Co-inductive types</A></a>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc118">7.1&nbsp;&nbsp;General</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc119">105&nbsp;&nbsp;How can I prove that two constructors are different?</A>
<LI CLASS="li-toc"><A HREF="#htoc120">106&nbsp;&nbsp;During an inductive proof, how to get rid of impossible cases of an inductive definition?</A>
<LI CLASS="li-toc"><A HREF="#htoc121">107&nbsp;&nbsp;How can I prove that 2 terms in an inductive set are equal? Or different?</A>
<LI CLASS="li-toc"><A HREF="#htoc122">108&nbsp;&nbsp;Why is the proof of <TT>0+n=n</TT> on natural numbers
trivial but the proof of <TT>n+0=n</TT> is not?</A>
<LI CLASS="li-toc"><A HREF="#htoc123">109&nbsp;&nbsp;Why is dependent elimination in Prop not
available by default?</A>
<LI CLASS="li-toc"><A HREF="#htoc124">110&nbsp;&nbsp;Argh! I cannot write expressions like &#8220;&nbsp;<TT>if n &lt;= p then p else n</TT>&nbsp;&#8221;, as in any programming language</A>
<LI CLASS="li-toc"><A HREF="#htoc125">111&nbsp;&nbsp;I wrote my own decision procedure for &#8804;, which
is much faster than yours, but proving such theorems as
 <TT>max_equiv</TT> seems to be quite difficult</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc126">7.2&nbsp;&nbsp;Recursion</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc127">112&nbsp;&nbsp;Why can't I define a non terminating program?</A>
<LI CLASS="li-toc"><A HREF="#htoc128">113&nbsp;&nbsp;Why only structurally well-founded loops are allowed?</A>
<LI CLASS="li-toc"><A HREF="#htoc129">114&nbsp;&nbsp;How to define loops based on non structurally smaller
recursive calls?</A>
<LI CLASS="li-toc"><A HREF="#htoc130">115&nbsp;&nbsp;What is behind the accessibility and well-foundedness proofs?</A>
<LI CLASS="li-toc"><A HREF="#htoc131">116&nbsp;&nbsp;How to perform simultaneous double induction?</A>
<LI CLASS="li-toc"><A HREF="#htoc132">117&nbsp;&nbsp;How to define a function by simultaneous double recursion?</A>
<LI CLASS="li-toc"><A HREF="#htoc133">118&nbsp;&nbsp;How to perform nested and double induction?</A>
<LI CLASS="li-toc"><A HREF="#htoc134">119&nbsp;&nbsp;How to define a function by nested recursion?</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc135">7.3&nbsp;&nbsp;Co-inductive types</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc136">120&nbsp;&nbsp;I have a cofixpoint <I>t</I>:=<I>F</I>(<I>t</I>) and I want to prove <I>t</I>=<I>F</I>(<I>t</I>). How to do it?</A>
</UL>
</UL>
<LI CLASS="li-toc"><a name="sum8"><A HREF="#htoc137">8&nbsp;&nbsp;Syntax and notations</A></a>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc138">121&nbsp;&nbsp;I do not want to type &#8220;forall&#8221; because it is too long, what can I do?</A>
<LI CLASS="li-toc"><A HREF="#htoc139">122&nbsp;&nbsp;How can I define a notation for square?</A>
<LI CLASS="li-toc"><A HREF="#htoc140">123&nbsp;&nbsp;Why &#8220;no associativity&#8221; and &#8220;left associativity&#8221; at the same level does not work?</A>
<LI CLASS="li-toc"><A HREF="#htoc141">124&nbsp;&nbsp;How can I know the associativity associated with a level?</A>
</UL>
</UL>
<LI CLASS="li-toc"><a name="sum9"><A HREF="#htoc142">9&nbsp;&nbsp;Modules</A></a>
<LI CLASS="li-toc"><a name="sum10"><A HREF="#htoc143">10&nbsp;&nbsp;<SPAN STYLE="font-variant:small-caps">Ltac</SPAN></A></a>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc144">125&nbsp;&nbsp;What is <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc145">126&nbsp;&nbsp;Why do I always get the same error message?</A>
<LI CLASS="li-toc"><A HREF="#htoc146">127&nbsp;&nbsp;Is there any printing command in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc147">128&nbsp;&nbsp;What is the syntax for let in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc148">129&nbsp;&nbsp;What is the syntax for pattern matching in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc149">130&nbsp;&nbsp;What is the semantics for &#8220;match goal&#8221;?</A>
<LI CLASS="li-toc"><A HREF="#htoc150">131&nbsp;&nbsp;Why can't I use a &#8220;match goal&#8221; returning a tactic in a non
tail-recursive position?</A>
<LI CLASS="li-toc"><A HREF="#htoc151">132&nbsp;&nbsp;How can I generate a new name?</A>
<LI CLASS="li-toc"><A HREF="#htoc152">133&nbsp;&nbsp;How can I define static and dynamic code?</A>
</UL>
</UL>
<LI CLASS="li-toc"><a name="sum11"><A HREF="#htoc153">11&nbsp;&nbsp;Tactics written in Ocaml</A></a>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc154">134&nbsp;&nbsp;Can you show me an example of a tactic written in OCaml?</A>
</UL>
</UL>
<LI CLASS="li-toc"><a name="sum12"><A HREF="#htoc155">12&nbsp;&nbsp;Case studies</A></a>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc156">135&nbsp;&nbsp;How can I define vectors or lists of size n?</A>
<LI CLASS="li-toc"><A HREF="#htoc157">136&nbsp;&nbsp;How to prove that 2 sets are different?</A>
<LI CLASS="li-toc"><A HREF="#htoc158">137&nbsp;&nbsp;Is there an axiom-free proof of Streicher's axiom <I>K</I> for
the equality on <TT>nat</TT>?</A>
<LI CLASS="li-toc"><A HREF="#htoc159">138&nbsp;&nbsp;How to prove that two proofs of <TT>n&lt;=m</TT> on <TT>nat</TT> are equal?</A>
<LI CLASS="li-toc"><A HREF="#htoc160">139&nbsp;&nbsp;How to exploit equalities on sets</A>
<LI CLASS="li-toc"><A HREF="#htoc161">140&nbsp;&nbsp;I have a problem of dependent elimination on
proofs, how to solve it?</A>
<LI CLASS="li-toc"><A HREF="#htoc162">141&nbsp;&nbsp;And what if I want to prove the following?</A>
</UL>
</UL>
<LI CLASS="li-toc"><a name="sum13"><A HREF="#htoc163">13&nbsp;&nbsp;Publishing tools</A></a>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc164">142&nbsp;&nbsp;How can I generate some latex from my development?</A>
<LI CLASS="li-toc"><A HREF="#htoc165">143&nbsp;&nbsp;How can I generate some HTML from my development?</A>
<LI CLASS="li-toc"><A HREF="#htoc166">144&nbsp;&nbsp;How can I generate some dependency graph from my development?</A>
<LI CLASS="li-toc"><A HREF="#htoc167">145&nbsp;&nbsp;How can I cite some <SPAN STYLE="font-variant:small-caps">Coq</SPAN> in my latex document?</A>
<LI CLASS="li-toc"><A HREF="#htoc168">146&nbsp;&nbsp;How can I cite the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> reference manual?</A>
<LI CLASS="li-toc"><A HREF="#htoc169">147&nbsp;&nbsp;Where can I publish my developments in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc170">148&nbsp;&nbsp;How can I read my proof in natural language?</A>
</UL>
</UL>
<LI CLASS="li-toc"<a name="sum14">><A HREF="#htoc171">14&nbsp;&nbsp;<SPAN STYLE="font-variant:small-caps">CoqIde</SPAN></A></a>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc172">149&nbsp;&nbsp;What is <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN>?</A>
<LI CLASS="li-toc"><A HREF="#htoc173">150&nbsp;&nbsp;How to enable Emacs keybindings?</A>
<LI CLASS="li-toc"><A HREF="#htoc174">151&nbsp;&nbsp;How to enable antialiased fonts?</A>
<LI CLASS="li-toc"><A HREF="#htoc175">152&nbsp;&nbsp;How to use those Forall and Exists pretty symbols?</A>
<LI CLASS="li-toc"><A HREF="#htoc176">153&nbsp;&nbsp;How to define an input method for non ASCII symbols?</A>
<LI CLASS="li-toc"><A HREF="#htoc177">154&nbsp;&nbsp;How to build a custom <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN> with user ml code?</A>
<LI CLASS="li-toc"><A HREF="#htoc178">155&nbsp;&nbsp;How to customize the shortcuts for menus?</A>
<LI CLASS="li-toc"><A HREF="#htoc179">156&nbsp;&nbsp;What encoding should I use? What is this \x{iiii} in my file?</A>
</UL>
</UL>
<LI CLASS="li-toc"><a name="sum15"><A HREF="#htoc180">15&nbsp;&nbsp;Extraction</A></a>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc181">157&nbsp;&nbsp;What is program extraction?</A>
<LI CLASS="li-toc"><A HREF="#htoc182">158&nbsp;&nbsp;Which language can I extract to?</A>
<LI CLASS="li-toc"><A HREF="#htoc183">159&nbsp;&nbsp;How can I extract an incomplete proof?</A>
</UL>
</UL>
<LI CLASS="li-toc"><a name="sum16"><A HREF="#htoc184">16&nbsp;&nbsp;Glossary</A></a>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc185">160&nbsp;&nbsp;Can you explain me what an evaluable constant is?</A>
<LI CLASS="li-toc"><A HREF="#htoc186">161&nbsp;&nbsp;What is a goal?</A>
<LI CLASS="li-toc"><A HREF="#htoc187">162&nbsp;&nbsp;What is a meta variable?</A>
<LI CLASS="li-toc"><A HREF="#htoc188">163&nbsp;&nbsp;What is Gallina?</A>
<LI CLASS="li-toc"><A HREF="#htoc189">164&nbsp;&nbsp;What is The Vernacular?</A>
<LI CLASS="li-toc"><A HREF="#htoc190">165&nbsp;&nbsp;What is a dependent type?</A>
<LI CLASS="li-toc"><A HREF="#htoc191">166&nbsp;&nbsp;What is a proof by reflection?</A>
<LI CLASS="li-toc"><A HREF="#htoc192">167&nbsp;&nbsp;What is intuitionistic logic?</A>
<LI CLASS="li-toc"><A HREF="#htoc193">168&nbsp;&nbsp;What is proof-irrelevance?</A>
<LI CLASS="li-toc"><A HREF="#htoc194">169&nbsp;&nbsp;What is the difference between opaque and transparent?</A>
</UL>
</UL>
<LI CLASS="li-toc"><a name="sum17"><A HREF="#htoc195">17&nbsp;&nbsp;Troubleshooting</A></a>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc196">170&nbsp;&nbsp;What can I do when <TT>Qed.</TT> is slow?</A>
<LI CLASS="li-toc"><A HREF="#htoc197">171&nbsp;&nbsp;Why <TT>Reset Initial.</TT> does not work when using <TT>coqc</TT>?</A>
<LI CLASS="li-toc"><A HREF="#htoc198">172&nbsp;&nbsp;What can I do if I get &#8220;No more subgoals but non-instantiated existential variables&#8221;?</A>
<LI CLASS="li-toc"><A HREF="#htoc199">173&nbsp;&nbsp;What can I do if I get &#8220;Cannot solve a second-order unification problem&#8221;?</A>
<LI CLASS="li-toc"><A HREF="#htoc200">174&nbsp;&nbsp;Why does <SPAN STYLE="font-variant:small-caps">Coq</SPAN> tell me that <TT>{x:A|(P x)}</TT> is not convertible with <TT>(sig A P)</TT>?</A>
<LI CLASS="li-toc"><A HREF="#htoc201">175&nbsp;&nbsp;I copy-paste a term and <SPAN STYLE="font-variant:small-caps">Coq</SPAN> says it is not convertible
 to the original term. Sometimes it even says the copied term is not
well-typed.</A>
</UL>
</UL>
<LI CLASS="li-toc"><a name="sum18"><A HREF="#htoc202">18&nbsp;&nbsp;Conclusion and Farewell.</A></a>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc203">176&nbsp;&nbsp;What if my question isn't answered here?</A>
</UL>
</UL>
</UL>

<!--TOC section Introduction-->

<H2 CLASS="section"><A NAME="htoc1">1</A>&nbsp;&nbsp;Introduction</H2><!--SEC END -->

This FAQ is the sum of the questions that came to mind as we developed
proofs in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. Since we are singularly short-minded, we wrote the
answers we found on bits of papers to have them at hand whenever the
situation occurs again. This is pretty much the result of that: a
collection of tips one can refer to when proofs become intricate. Yes,
this means we won't take the blame for the shortcomings of this
FAQ. But if you want to contribute and send in your own question and
answers, feel free to write to us...<BR>
<BR>
<!--TOC section Presentation-->

<H2 CLASS="section"><A NAME="htoc2">2</A>&nbsp;&nbsp;Presentation</H2><!--SEC END -->

<!--TOC subsubsection What is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc3">1</A>&nbsp;&nbsp;What is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END -->
<A NAME="whatiscoq"></A> 
The <SPAN STYLE="font-variant:small-caps">Coq</SPAN> tool is a formal proof management system: a proof done with <SPAN STYLE="font-variant:small-caps">Coq</SPAN> is mechanically checked by the machine. 
In particular, <SPAN STYLE="font-variant:small-caps">Coq</SPAN> allows:
<UL CLASS="itemize"><LI CLASS="li-itemize">
 the definition of mathematical objects and programming objects,
 <LI CLASS="li-itemize">to state mathematical theorems and software specifications,
 <LI CLASS="li-itemize">to interactively develop formal proofs of these theorems,
 <LI CLASS="li-itemize">to check these proofs by a small certification &#8220;kernel&#8221;.
</UL>
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> is based on a logical framework called &#8220;Calculus of Inductive
Constructions&#8221; extended by a modular development system for theories.<BR>
<BR>
<!--TOC subsubsection Did you really need to name it like that?-->

<H4 CLASS="subsubsection"><A NAME="htoc4">2</A>&nbsp;&nbsp;Did you really need to name it like that?</H4><!--SEC END -->

Some French computer scientists have a tradition of naming their
software as animal species: Caml, Elan, Foc or Phox are examples
of this tacit convention. In French, &#8220;coq&#8221; means rooster, and it
sounds like the initials of the Calculus of Constructions CoC on which
it is based.<BR>
<BR>
<!--TOC subsubsection Is <SPAN STYLE="font-variant:small-caps">Coq</SPAN> a theorem prover?-->

<H4 CLASS="subsubsection"><A NAME="htoc5">3</A>&nbsp;&nbsp;Is <SPAN STYLE="font-variant:small-caps">Coq</SPAN> a theorem prover?</H4><!--SEC END -->

<SPAN STYLE="font-variant:small-caps">Coq</SPAN> comes with decision and semi-decision procedures (
propositional calculus, Presburger's arithmetic, ring and field
simplification, resolution, ...) but the main style for proving
theorems is interactively by using LCF-style tactics.<BR>
<BR>
<!--TOC subsubsection What are the other theorem provers?-->

<H4 CLASS="subsubsection"><A NAME="htoc6">4</A>&nbsp;&nbsp;What are the other theorem provers?</H4><!--SEC END -->
 
Many other theorem provers are available for use nowadays. 
Isabelle, HOL, HOL Light, Lego, Nuprl, PVS are examples of provers that are fairly similar
to <SPAN STYLE="font-variant:small-caps">Coq</SPAN> by the way they interact with the user. Other relatives of
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> are ACL2, Agda/Alfa, Twelf, Kiv, Mizar, NqThm, 
Omega...
<BR>
<BR>
<!--TOC subsubsection What do I have to trust when I see a proof checked by Coq?-->

<H4 CLASS="subsubsection"><A NAME="htoc7">5</A>&nbsp;&nbsp;What do I have to trust when I see a proof checked by Coq?</H4><!--SEC END -->

You have to trust:
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B>The theory behind Coq</B><DD CLASS="dd-description"> The theory of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> version 8.0 is
generally admitted to be consistent wrt Zermelo-Fraenkel set theory +
inaccessible cardinals. Proofs of consistency of subsystems of the
theory of Coq can be found in the literature.
<DT CLASS="dt-description"><B>The Coq kernel implementation</B><DD CLASS="dd-description"> You have to trust that the
implementation of the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> kernel mirrors the theory behind <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. The
kernel is intentionally small to limit the risk of conceptual or
accidental implementation bugs.
<DT CLASS="dt-description"><B>The Objective Caml compiler</B><DD CLASS="dd-description"> The <SPAN STYLE="font-variant:small-caps">Coq</SPAN> kernel is written using the
Objective Caml language but it uses only the most standard features
(no object, no label ...), so that it is highly unprobable that an
Objective Caml bug breaks the consistency of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> without breaking all
other kinds of features of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> or of other software compiled with
Objective Caml.
<DT CLASS="dt-description"><B>Your hardware</B><DD CLASS="dd-description"> In theory, if your hardware does not work
properly, it can accidentally be the case that False becomes
provable. But it is more likely the case that the whole <SPAN STYLE="font-variant:small-caps">Coq</SPAN> system
will be unusable. You can check your proof using different computers
if you feel the need to.
<DT CLASS="dt-description"><B>Your axioms</B><DD CLASS="dd-description"> Your axioms must be consistent with the theory
behind <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.
</DL>
<!--TOC subsubsection Where can I find information about the theory behind <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc8">6</A>&nbsp;&nbsp;Where can I find information about the theory behind <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END -->

<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B>The Calculus of Inductive Constructions</B><DD CLASS="dd-description"> The
<A HREF="http://coq.inria.fr/doc/Reference-Manual006.html">corresponding</A>
chapter and the chapter on
<A HREF="http://coq.inria.fr/doc/Reference-Manual007.html">modules</A> in
the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> Reference Manual.
<DT CLASS="dt-description"><B>Type theory</B><DD CLASS="dd-description"> A book&nbsp;[<A HREF="#ProofsTypes"><CITE>11</CITE></A>] or some lecture
notes&nbsp;[<A HREF="#Types:Dowek"><CITE>8</CITE></A>].
<DT CLASS="dt-description"><B>Inductive types</B><DD CLASS="dd-description">
Christine Paulin-Mohring's habilitation thesis&nbsp;[<A HREF="#Pau96b"><CITE>19</CITE></A>].
<DT CLASS="dt-description"><B>Co-Inductive types</B><DD CLASS="dd-description">
Eduardo Giménez' thesis&nbsp;[<A HREF="#EGThese"><CITE>9</CITE></A>].
<DT CLASS="dt-description"><B>Miscellaneous</B><DD CLASS="dd-description"> A
<A HREF="http://coq.inria.fr/doc/biblio.html">bibliography</A> about Coq
</DL>
<!--TOC subsubsection How can I use <SPAN STYLE="font-variant:small-caps">Coq</SPAN> to prove programs?-->

<H4 CLASS="subsubsection"><A NAME="htoc9">7</A>&nbsp;&nbsp;How can I use <SPAN STYLE="font-variant:small-caps">Coq</SPAN> to prove programs?</H4><!--SEC END -->

You can either extract a program from a proof by using the extraction
mechanism or use dedicated tools, such as
<A HREF="http://why.lri.fr"><SPAN STYLE="font-variant:small-caps">Why</SPAN></A>,
<A HREF="http://krakatoa.lri.fr"><SPAN STYLE="font-variant:small-caps">Krakatoa</SPAN></A>,
<A HREF="http://why.lri.fr/caduceus/index.en.html"><SPAN STYLE="font-variant:small-caps">Caduceus</SPAN></A>, to prove
annotated programs written in other languages.<BR>
<BR>
<!--TOC subsubsection How old is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc10">8</A>&nbsp;&nbsp;How old is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END -->

The first implementation is from 1985 (it was named <FONT COLOR=purple>CoC</FONT> which is
the acronym of the name of the logic it implemented: the Calculus of
Constructions). The first official release of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> (version 4.10)
was distributed in 1989.<BR>
<BR>
<!--TOC subsubsection What are the <SPAN STYLE="font-variant:small-caps">Coq</SPAN>-related tools?-->

<H4 CLASS="subsubsection"><A NAME="htoc11">9</A>&nbsp;&nbsp;What are the <SPAN STYLE="font-variant:small-caps">Coq</SPAN>-related tools?</H4><!--SEC END -->

There are graphical user interfaces:
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B>Coqide</B><DD CLASS="dd-description"> A GTK based GUI for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.
<DT CLASS="dt-description"><B>Pcoq</B><DD CLASS="dd-description"> A GUI for <SPAN STYLE="font-variant:small-caps">Coq</SPAN> with proof by pointing and pretty printing.
<DT CLASS="dt-description"><B>coqwc</B><DD CLASS="dd-description"> A tool similar to <TT>wc</TT> to count lines in <SPAN STYLE="font-variant:small-caps">Coq</SPAN> files.
<DT CLASS="dt-description"><B>Proof General</B><DD CLASS="dd-description"> A emacs mode for <SPAN STYLE="font-variant:small-caps">Coq</SPAN> and many other proof assistants.
</DL>
There are documentation and browsing tools:
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B>Helm/Mowgli</B><DD CLASS="dd-description"> A rendering, searching and publishing tool.
<DT CLASS="dt-description"><B>coq-tex</B><DD CLASS="dd-description"> A tool to insert <SPAN STYLE="font-variant:small-caps">Coq</SPAN> examples within .tex files. 
<DT CLASS="dt-description"><B>coqdoc</B><DD CLASS="dd-description"> A documentation tool for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.
</DL>
There are front-ends for specific languages:
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B>Why</B><DD CLASS="dd-description"> A back-end generator of verification conditions.
<DT CLASS="dt-description"><B>Krakatoa</B><DD CLASS="dd-description"> A Java code certification tool that uses both <SPAN STYLE="font-variant:small-caps">Coq</SPAN> and <SPAN STYLE="font-variant:small-caps">Why</SPAN> to verify the soundness of implementations with regards to the specifications.
<DT CLASS="dt-description"><B>Caduceus</B><DD CLASS="dd-description"> A C code certification tool that uses both <SPAN STYLE="font-variant:small-caps">Coq</SPAN> and <SPAN STYLE="font-variant:small-caps">Why</SPAN>.
<DT CLASS="dt-description"><B>Zenon</B><DD CLASS="dd-description"> A first-order theorem prover.
<DT CLASS="dt-description"><B>Focal</B><DD CLASS="dd-description"> The <A HREF="http://focal.inria.fr">Focal</A> project aims at building an environment to develop certified computer algebra libraries. 
</DL>
<!--TOC subsubsection What are the high-level tactics of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>-->

<H4 CLASS="subsubsection"><A NAME="htoc12">10</A>&nbsp;&nbsp;What are the high-level tactics of <SPAN STYLE="font-variant:small-caps">Coq</SPAN></H4><!--SEC END -->

<UL CLASS="itemize"><LI CLASS="li-itemize">
Decision of quantifier-free Presburger's Arithmetic
<LI CLASS="li-itemize">Simplification of expressions on rings and fields
<LI CLASS="li-itemize">Decision of closed systems of equations
<LI CLASS="li-itemize">Semi-decision of first-order logic
<LI CLASS="li-itemize">Prolog-style proof search, possibly involving equalities
</UL>
<!--TOC subsubsection What are the main libraries available for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>-->

<H4 CLASS="subsubsection"><A NAME="htoc13">11</A>&nbsp;&nbsp;What are the main libraries available for <SPAN STYLE="font-variant:small-caps">Coq</SPAN></H4><!--SEC END -->

<UL CLASS="itemize"><LI CLASS="li-itemize">
Basic Peano's arithmetic, binary integer numbers, rational numbers,
<LI CLASS="li-itemize">Real analysis,
<LI CLASS="li-itemize">Libraries for lists, boolean, maps, floating-point numbers,
<LI CLASS="li-itemize">Libraries for relations, sets and constructive algebra,
<LI CLASS="li-itemize">Geometry
</UL>
<!--TOC subsubsection What are the mathematical applications for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc14">12</A>&nbsp;&nbsp;What are the mathematical applications for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END -->

<SPAN STYLE="font-variant:small-caps">Coq</SPAN> is used for formalizing mathematical theories, for teaching,
and for proving properties of algorithms or programs libraries.<BR>
<BR>
The largest mathematical formalization has been done at the University
of Nijmegen (see the
<A HREF="http://c-corn.cs.ru.nl">Constructive Coq
Repository at Nijmegen</A>).<BR>
<BR>
A symbolic step has also been obtained by formalizing in full a proof
of the Four Color Theorem.<BR>
<BR>
<!--TOC subsubsection What are the industrial applications for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc15">13</A>&nbsp;&nbsp;What are the industrial applications for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END -->

<SPAN STYLE="font-variant:small-caps">Coq</SPAN> is used e.g. to prove properties of the JavaCard system
(especially by Schlumberger and Trusted Logic). It has
also been used to formalize the semantics of the Lucid-Synchrone
data-flow synchronous calculus used by Esterel-Technologies.<BR>
<BR>
<!--TOC section Documentation-->

<H2 CLASS="section"><A NAME="htoc16">3</A>&nbsp;&nbsp;Documentation</H2><!--SEC END -->

<!--TOC subsubsection Where can I find documentation about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc17">14</A>&nbsp;&nbsp;Where can I find documentation about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END -->
 
All the documentation about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, from the reference manual&nbsp;[<A HREF="#Coq:manual"><CITE>17</CITE></A>] to
friendly tutorials&nbsp;[<A HREF="#Coq:Tutorial"><CITE>15</CITE></A>] and documentation of the standard library, is available 
<A HREF="http://coq.inria.fr/doc-eng.html">online</A>.
All these documents are viewable either in browsable HTML, or as
downloadable postscripts.<BR>
<BR>
<!--TOC subsubsection Where can I find this FAQ on the web?-->

<H4 CLASS="subsubsection"><A NAME="htoc18">15</A>&nbsp;&nbsp;Where can I find this FAQ on the web?</H4><!--SEC END -->

This FAQ is available online at <A HREF="http://coq.inria.fr/doc/faq.html"><TT>http://coq.inria.fr/doc/faq.html</TT></A>.<BR>
<BR>
<!--TOC subsubsection How can I submit suggestions / improvements / additions for this FAQ?-->

<H4 CLASS="subsubsection"><A NAME="htoc19">16</A>&nbsp;&nbsp;How can I submit suggestions / improvements / additions for this FAQ?</H4><!--SEC END -->

This FAQ is unfinished (in the sense that there are some obvious
sections that are missing). Please send contributions to <TT>Florent.Kirchner at lix.polytechnique.fr</TT> and <TT>Julien.Narboux at inria.fr</TT>.<BR>
<BR>
<!--TOC subsubsection Is there any mailing list about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc20">17</A>&nbsp;&nbsp;Is there any mailing list about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END -->
 
The main <SPAN STYLE="font-variant:small-caps">Coq</SPAN> mailing list is <TT>coq-club@pauillac.inria.fr</TT>, which
broadcasts questions and suggestions about the implementation, the
logical formalism or proof developments. See
<A HREF="http://coq.inria.fr/mailman/listinfo/coq-club"><TT>http://pauillac.inria.fr/mailman/listinfo/coq-club</TT></A> for
subscription. For bugs reports see question <A HREF="#coqbug">22</A>.<BR>
<BR>
<!--TOC subsubsection Where can I find an archive of the list?-->

<H4 CLASS="subsubsection"><A NAME="htoc21">18</A>&nbsp;&nbsp;Where can I find an archive of the list?</H4><!--SEC END -->

The archives of the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> mailing list are available at
<A HREF="http://pauillac.inria.fr/pipermail/coq-club"><TT>http://coq.inria.fr/pipermail/coq-club</TT></A>.<BR>
<BR>
<!--TOC subsubsection How can I be kept informed of new releases of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc22">19</A>&nbsp;&nbsp;How can I be kept informed of new releases of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END -->

New versions of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> are announced on the coq-club mailing list. If you only want to receive information about new releases, you can subscribe to <SPAN STYLE="font-variant:small-caps">Coq</SPAN> on <A HREF="http://freshmeat.net/projects/coq/"><TT>http://freshmeat.net/projects/coq/</TT></A>.<BR>
<BR>
<!--TOC subsubsection Is there any book about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc23">20</A>&nbsp;&nbsp;Is there any book about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END -->

The first book on <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, Yves Bertot and Pierre Castéran's Coq'Art has been published by Springer-Verlag in 2004:
<BLOCKQUOTE CLASS="quote">
&#8220;This book provides a pragmatic introduction to the development of
proofs and certified programs using <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. With its large collection of
examples and exercises it is an invaluable tool for researchers,
students, and engineers interested in formal methods and the
development of zero-default software.&#8221;
</BLOCKQUOTE>
<!--TOC subsubsection Where can I find some <SPAN STYLE="font-variant:small-caps">Coq</SPAN> examples?-->

<H4 CLASS="subsubsection"><A NAME="htoc24">21</A>&nbsp;&nbsp;Where can I find some <SPAN STYLE="font-variant:small-caps">Coq</SPAN> examples?</H4><!--SEC END -->
 
There are examples in the manual&nbsp;[<A HREF="#Coq:manual"><CITE>17</CITE></A>] and in the
Coq'Art&nbsp;[<A HREF="#Coq:coqart"><CITE>2</CITE></A>] exercises <A HREF="http://www.labri.fr/Perso/~casteran/CoqArt/index.html"><TT>http://www.labri.fr/Perso/~casteran/CoqArt/index.html</TT></A>.
You can also find large developments using
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> in the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> user contributions:
<A HREF="http://coq.inria.fr/contrib-eng.html"><TT>http://coq.inria.fr/contrib-eng.html</TT></A>.<BR>
<BR>
<!--TOC subsubsection How can I report a bug?-->

<H4 CLASS="subsubsection"><A NAME="htoc25">22</A>&nbsp;&nbsp;How can I report a bug?</H4><!--SEC END -->
<A NAME="coqbug"></A>
You can use the web interface accessible at <A HREF="http://coq.inria.fr"><TT>http://coq.inria.fr</TT></A>, link &#8220;contacts&#8221;.<BR>
<BR>
<!--TOC section Installation-->

<H2 CLASS="section"><A NAME="htoc26">4</A>&nbsp;&nbsp;Installation</H2><!--SEC END -->

<!--TOC subsubsection What is the license of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc27">23</A>&nbsp;&nbsp;What is the license of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END -->

<SPAN STYLE="font-variant:small-caps">Coq</SPAN> is distributed under the GNU Lesser General License
(LGPL).<BR>
<BR>
<!--TOC subsubsection Where can I find the sources of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc28">24</A>&nbsp;&nbsp;Where can I find the sources of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END -->

The sources of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> can be found online in the tar.gz'ed packages
(<A HREF="http://coq.inria.fr"><TT>http://coq.inria.fr</TT></A>, link
&#8220;download&#8221;). Development sources can be accessed at
<A HREF="http://coq.gforge.inria.fr/"><TT>http://coq.gforge.inria.fr/</TT></A><BR>
<BR>
<!--TOC subsubsection On which platform is <SPAN STYLE="font-variant:small-caps">Coq</SPAN> available?-->

<H4 CLASS="subsubsection"><A NAME="htoc29">25</A>&nbsp;&nbsp;On which platform is <SPAN STYLE="font-variant:small-caps">Coq</SPAN> available?</H4><!--SEC END -->

Compiled binaries are available for Linux, MacOS X, and Windows. The
sources can be easily compiled on all platforms supporting Objective
Caml.<BR>
<BR>
<!--TOC section The logic of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>-->

<H2 CLASS="section"><A NAME="htoc30">5</A>&nbsp;&nbsp;The logic of <SPAN STYLE="font-variant:small-caps">Coq</SPAN></H2><!--SEC END -->

<!--TOC subsection General-->

<H3 CLASS="subsection"><A NAME="htoc31">5.1</A>&nbsp;&nbsp;General</H3><!--SEC END -->

<!--TOC subsubsection What is the logic of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc32">26</A>&nbsp;&nbsp;What is the logic of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END -->

<SPAN STYLE="font-variant:small-caps">Coq</SPAN> is based on an axiom-free type theory called
the Calculus of Inductive Constructions (see Coquand [<A HREF="#CoHu86"><CITE>6</CITE></A>],
Luo&nbsp;[<A HREF="#Luo90"><CITE>16</CITE></A>]
and Coquand&ndash;Paulin-Mohring [<A HREF="#CoPa89"><CITE>7</CITE></A>]). It includes higher-order
functions and predicates, inductive and co-inductive datatypes and
predicates, and a stratified hierarchy of sets.<BR>
<BR>
<!--TOC subsubsection Is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s logic intuitionistic or classical?-->

<H4 CLASS="subsubsection"><A NAME="htoc33">27</A>&nbsp;&nbsp;Is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s logic intuitionistic or classical?</H4><!--SEC END -->

<SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s logic is modular. The core logic is intuitionistic
(i.e. excluded-middle <I>A</I>&or;&not; <I>A</I> is not granted by default). It can
be extended to classical logic on demand by requiring an
optional module stating <I>A</I>&or;&not; <I>A</I>.<BR>
<BR>
<!--TOC subsubsection Can I define non-terminating programs in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc34">28</A>&nbsp;&nbsp;Can I define non-terminating programs in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END -->

All programs in <SPAN STYLE="font-variant:small-caps">Coq</SPAN> are terminating. Especially, loops
must come with an evidence of their termination. <BR>
<BR>
Non-terminating programs can be simulated by passing around a
bound on how long the program is allowed to run before dying.<BR>
<BR>
<!--TOC subsubsection How is equational reasoning working in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc35">29</A>&nbsp;&nbsp;How is equational reasoning working in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END -->

<SPAN STYLE="font-variant:small-caps">Coq</SPAN> comes with an internal notion of computation called
<EM>conversion</EM> (e.g. (<I>x</I>+1)+<I>y</I> is internally equivalent to
(<I>x</I>+<I>y</I>)+1; similarly applying argument <I>a</I> to a function mapping <I>x</I>
to some expression <I>t</I> converts to the expression <I>t</I> where <I>x</I> is
replaced by <I>a</I>). This notion of conversion (which is decidable
because <SPAN STYLE="font-variant:small-caps">Coq</SPAN> programs are terminating) covers a certain part of
equational reasoning but is limited to sequential evaluation of
expressions of (not necessarily closed) programs. Besides conversion,
equations have to be treated by hand or using specialised tactics.<BR>
<BR>
<!--TOC subsection Axioms-->

<H3 CLASS="subsection"><A NAME="htoc36">5.2</A>&nbsp;&nbsp;Axioms</H3><!--SEC END -->

<!--TOC subsubsection What axioms can be safely added to <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc37">30</A>&nbsp;&nbsp;What axioms can be safely added to <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END -->

There are a few typical useful axioms that are independent from the
Calculus of Inductive Constructions and that can be safely added to
<SPAN STYLE="font-variant:small-caps">Coq</SPAN>. These axioms are stated in the directory <TT>Logic</TT> of the
standard library of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. The most interesting ones are
<UL CLASS="itemize"><LI CLASS="li-itemize">
Excluded-middle: &forall; <I>A</I>:<I>Prop</I>, <I>A</I> &or; &not; <I>A</I>
<LI CLASS="li-itemize">Proof-irrelevance: &forall; <I>A</I>:<I>Prop</I> &forall; <I>p</I><SUB>1</SUB> <I>p</I><SUB>2</SUB>:<I>A</I>, <I>p</I><SUB>1</SUB>=<I>p</I><SUB>2</SUB>
<LI CLASS="li-itemize">Unicity of equality proofs (or equivalently Streicher's axiom <I>K</I>):
&forall; <I>A</I> &forall; <I>x</I> <I>y</I>:<I>A</I> &forall; <I>p</I><SUB>1</SUB> <I>p</I><SUB>2</SUB>:<I>x</I>=<I>y</I>, <I>p</I><SUB>1</SUB>=<I>p</I><SUB>2</SUB>
<LI CLASS="li-itemize">The axiom of unique choice: &forall; <I>x</I> &exist;! <I>y</I> <I>R</I>(<I>x</I>,<I>y</I>) &rarr; &exist; <I>f</I> &forall; <I>x</I> <I>R</I>(<I>x</I>,<I>f</I>(<I>x</I>))
<LI CLASS="li-itemize">The functional axiom of choice: &forall; <I>x</I> &exist; <I>y</I> <I>R</I>(<I>x</I>,<I>y</I>) &rarr; &exist; <I>f</I> &forall; <I>x</I> <I>R</I>(<I>x</I>,<I>f</I>(<I>x</I>))
<LI CLASS="li-itemize">Extensionality of predicates: &forall; <I>P</I> <I>Q</I>:<I>A</I>&rarr; <I>Prop</I>, (&forall; <I>x</I>, <I>P</I>(<I>x</I>) &#8596; <I>Q</I>(<I>x</I>)) &rarr; <I>P</I>=<I>Q</I>
<LI CLASS="li-itemize">Extensionality of functions: &forall; <I>f</I> <I>g</I>:<I>A</I>&rarr; <I>B</I>, (&forall; <I>x</I>, <I>f</I>(<I>x</I>)=<I>g</I>(<I>x</I>)) &rarr; <I>f</I>=<I>g</I>
</UL>
Here is a summary of the relative strength of these axioms, most
proofs can be found in directory <TT>Logic</TT> of the standard library.
The justification of their validity relies on the interpretability in
set theory.<BR>
<BR>


<!--TOC subsubsection What standard axioms are inconsistent with <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc38">31</A>&nbsp;&nbsp;What standard axioms are inconsistent with <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END -->

The axiom of unique choice together with classical logic
(e.g. excluded-middle) are inconsistent in the variant of the Calculus
of Inductive Constructions where <TT>Set</TT> is impredicative.<BR>
<BR>
As a consequence, the functional form of the axiom of choice and
excluded-middle, or any form of the axiom of choice together with
predicate extensionality are inconsistent in the <TT>Set</TT>-impredicative
version of the Calculus of Inductive Constructions.<BR>
<BR>
The main purpose of the <TT>Set</TT>-predicative restriction of the Calculus
of Inductive Constructions is precisely to accommodate these axioms
which are quite standard in mathematical usage.<BR>
<BR>
The <TT><I>Set</I></TT>-predicative system is commonly considered consistent by
interpreting it in a standard set-theoretic boolean model, even with
classical logic, axiom of choice and predicate extensionality added.<BR>
<BR>
<!--TOC subsubsection What is Streicher's axiom <I>K</I>-->

<H4 CLASS="subsubsection"><A NAME="htoc39">32</A>&nbsp;&nbsp;What is Streicher's axiom <I>K</I></H4><!--SEC END -->

<A NAME="Streicher"></A>
Streicher's axiom <I>K</I>&nbsp;[<A HREF="#HofStr98"><CITE>13</CITE></A>] is an axiom that asserts
dependent elimination of reflexive equality proofs.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Axiom&nbsp;Streicher_K&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;(A:Type)&nbsp;(x:A)&nbsp;(P:&nbsp;x=x&nbsp;-&gt;&nbsp;Prop),</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;(refl_equal&nbsp;x)&nbsp;-&gt;&nbsp;forall&nbsp;p:&nbsp;x=x,&nbsp;P&nbsp;p.</TT><BR>
</DIV>
<BR>
<BR>
In the general case, axiom <I>K</I> is an independent statement of the
Calculus of Inductive Constructions. However, it is true on decidable
domains (see file <A HREF="http://coq.inria.fr/library/Coq.Logic.Eqdep_dec.html
"><TT>Eqdep_dec.v</TT></A>). It is also
trivially a consequence of proof-irrelevance (see
<A HREF="#proof-irrelevance">33</A>) hence of classical logic.<BR>
<BR>
Axiom <I>K</I> is equivalent to <EM>Uniqueness of Identity Proofs</EM> [<A HREF="#HofStr98"><CITE>13</CITE></A>]<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Axiom&nbsp;UIP&nbsp;:&nbsp;forall&nbsp;(A:Set)&nbsp;(x&nbsp;y:A)&nbsp;(p1&nbsp;p2:&nbsp;x=y),&nbsp;p1&nbsp;=&nbsp;p2.</TT><BR>
</DIV>
<BR>
<BR>
Axiom <I>K</I> is also equivalent to <EM>Uniqueness of Reflexive Identity Proofs</EM> [<A HREF="#HofStr98"><CITE>13</CITE></A>]<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Axiom&nbsp;UIP_refl&nbsp;:&nbsp;forall&nbsp;(A:Set)&nbsp;(x:A)&nbsp;(p:&nbsp;x=x),&nbsp;p&nbsp;=&nbsp;refl_equal&nbsp;x.</TT><BR>
</DIV>
<BR>
<BR>
Axiom <I>K</I> is also equivalent to <BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Axiom</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;eq_rec_eq&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(A:Set)&nbsp;(x:A)&nbsp;(P:&nbsp;A-&gt;Set)&nbsp;(p:P&nbsp;x)&nbsp;(h:&nbsp;x=x),</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;eq_rect&nbsp;x&nbsp;P&nbsp;p&nbsp;x&nbsp;h.</TT><BR>
</DIV>
<BR>
<BR>
It is also equivalent to the injectivity of dependent equality (dependent equality is itself equivalent to equality of dependent pairs).<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;eq_dep&nbsp;(U:Set)&nbsp;(P:U&nbsp;-&gt;&nbsp;Set)&nbsp;(p:U)&nbsp;(x:P&nbsp;p)&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;forall&nbsp;q:U,&nbsp;P&nbsp;q&nbsp;-&gt;&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eq_dep_intro&nbsp;:&nbsp;eq_dep&nbsp;U&nbsp;P&nbsp;p&nbsp;x&nbsp;p&nbsp;x.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Axiom</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;eq_dep_eq&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(U:Set)&nbsp;(u:U)&nbsp;(P:U&nbsp;-&gt;&nbsp;Set)&nbsp;(p1&nbsp;p2:P&nbsp;u),</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eq_dep&nbsp;U&nbsp;P&nbsp;u&nbsp;p1&nbsp;u&nbsp;p2&nbsp;-&gt;&nbsp;p1&nbsp;=&nbsp;p2.</TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection What is proof-irrelevance-->

<H4 CLASS="subsubsection"><A NAME="htoc40">33</A>&nbsp;&nbsp;What is proof-irrelevance</H4><!--SEC END -->

<A NAME="proof-irrelevance"></A>
A specificity of the Calculus of Inductive Constructions is to permit
statements about proofs. This leads to the question of comparing two
proofs of the same proposition. Identifying all proofs of the same
proposition is called <EM>proof-irrelevance</EM>:
<DIV CLASS="center">&forall; <I>A</I>:<TT><I>Prop</I></TT>, &forall; <I>p</I> <I>q</I>:<I>A</I>, <I>p</I>=<I>q</I>
</DIV> <BR>
<BR>
Proof-irrelevance (in <TT>Prop</TT>) can be assumed without contradiction in
<SPAN STYLE="font-variant:small-caps">Coq</SPAN>. It expresses that only provability matters, whatever the exact
form of the proof is. This is in harmony with the common purely
logical interpretation of <TT>Prop</TT>. Contrastingly, proof-irrelevance is
inconsistent in <TT>Set</TT> since there are types in <TT>Set</TT>, such as the
type of booleans, that are provably more than 2 elements.<BR>
<BR>
Proof-irrelevance (in <TT>Prop</TT>) is a consequence of classical logic
(see proofs in file <A HREF="http://coq.inria.fr/library/Coq.Logic.Classical.html
"><TT>Classical.v</TT></A> and
<A HREF="http://coq.inria.fr/library/Coq.Logic.Berardi.html
"><TT>Berardi.v</TT></A>). Proof-irrelevance is also a
consequence of propositional extensionality (i.e. <TT>(A &lt;-&gt; B)
-&gt; A=B</TT>, see the proof in file
<A HREF="http://coq.inria.fr/library/Coq.Logic.ClassicalFacts.html
"><TT>ClassicalFacts.v</TT></A>).<BR>
<BR>
Proof-irrelevance directly implies Streicher's axiom <I>K</I>.<BR>
<BR>
<!--TOC subsubsection What about functional extensionality?-->

<H4 CLASS="subsubsection"><A NAME="htoc41">34</A>&nbsp;&nbsp;What about functional extensionality?</H4><!--SEC END -->

Extensionality of functions is admittedly consistent with the
Set-predicative Calculus of Inductive Constructions.<BR>
<BR>
Let <TT>A</TT>, <TT>B</TT> be types. To deal with extensionality on 
<CODE>A-&gt;B</CODE> without relying on a general extensionality axiom, 
a possible approach is to define one's own extensional equality on
<CODE>A-&gt;B</CODE>.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;ext_eq&nbsp;(f&nbsp;g:&nbsp;A-&gt;B)&nbsp;:=&nbsp;forall&nbsp;x:A,&nbsp;f&nbsp;x&nbsp;=&nbsp;g&nbsp;x.</TT><BR>
</DIV>
<BR>
<BR>
and to reason on <CODE>A-&gt;B</CODE> as a setoid (see the Chapter on
Setoids in the Reference Manual).<BR>
<BR>
<!--TOC subsubsection Is <TT>Prop</TT> impredicative?-->

<H4 CLASS="subsubsection"><A NAME="htoc42">35</A>&nbsp;&nbsp;Is <TT>Prop</TT> impredicative?</H4><!--SEC END -->

Yes, the sort <TT>Prop</TT> of propositions is <EM>impredicative</EM>. Otherwise said, a statement of the form &forall;
<I>A</I>:<I>Prop</I>, <I>P</I>(<I>A</I>) can be instantiated by itself: if &forall; <I>A</I>:<TT><I>Prop</I></TT>, <I>P</I>(<I>A</I>)
is provable, then <I>P</I>(&forall; <I>A</I>:<TT><I>Prop</I></TT>, <I>P</I>(<I>A</I>)) is.<BR>
<BR>
<!--TOC subsubsection Is <TT>Set</TT> impredicative?-->

<H4 CLASS="subsubsection"><A NAME="htoc43">36</A>&nbsp;&nbsp;Is <TT>Set</TT> impredicative?</H4><!--SEC END -->

No, the sort <TT>Set</TT> lying at the bottom of the hierarchy of
computational types is <EM>predicative</EM> in the basic <SPAN STYLE="font-variant:small-caps">Coq</SPAN> system.
This means that a family of types in <TT>Set</TT>, e.g. &forall; <I>A</I>:<TT><I>Set</I></TT>, <I>A</I>
&rarr; <I>A</I>, is not a type in <TT>Set</TT> and it cannot be applied on
itself.<BR>
<BR>
However, the sort <TT>Set</TT> was impredicative in the original versions of
<SPAN STYLE="font-variant:small-caps">Coq</SPAN>. For backward compatibility, or for experiments by
knowledgeable users, the logic of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> can be set impredicative for
<TT>Set</TT> by calling <SPAN STYLE="font-variant:small-caps">Coq</SPAN> with the option <TT>-impredicative-set</TT>.<BR>
<BR>
<TT>Set</TT> has been made predicative from version 8.0 of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. The main
reason is to interact smoothly with a classical mathematical world
where both excluded-middle and the axiom of description are valid (see
file <A HREF="http://coq.inria.fr/library/Coq.Logic.ClassicalDescription.html
"><TT>ClassicalDescription.v</TT></A> for a
proof that excluded-middle and description implies the double negation
of excluded-middle in <TT>Set</TT> and file <TT>Hurkens_Set.v</TT> from the
user contribution <TT>Rocq/PARADOXES</TT> for a proof that
impredicativity of <TT>Set</TT> implies the simple negation of
excluded-middle in <TT>Set</TT>).<BR>
<BR>
<!--TOC subsubsection Is <TT>Type</TT> impredicative?-->

<H4 CLASS="subsubsection"><A NAME="htoc44">37</A>&nbsp;&nbsp;Is <TT>Type</TT> impredicative?</H4><!--SEC END -->

No, <TT>Type</TT> is stratified. This is hidden for the
user, but <SPAN STYLE="font-variant:small-caps">Coq</SPAN> internally maintains a set of constraints ensuring
stratification.<BR>
<BR>
If <TT>Type</TT> were impredicative then it would be possible to encode
Girard's systems <I>U</I>&minus; and <I>U</I> in <SPAN STYLE="font-variant:small-caps">Coq</SPAN> and it is known from Girard,
Coquand, Hurkens and Miquel that systems <I>U</I>&minus; and <I>U</I> are inconsistent
[Girard 1972, Coquand 1991, Hurkens 1993, Miquel 2001]. This encoding
can be found in file <TT>Logic/Hurkens.v</TT> of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> standard library.<BR>
<BR>
For instance, when the user see <TT>&forall; X:Type, X-&gt;X : Type</TT>, each
occurrence of <TT>Type</TT> is implicitly bound to a different level, say
&#945; and &beta; and the actual statement is <TT>forall X:Type(&#945;), X-&gt;X : Type(&beta;)</TT> with the constraint
&#945;&lt;&beta;.<BR>
<BR>
When a statement violates a constraint, the message <TT>Universe
inconsistency</TT> appears. Example: <TT>fun (x:Type) (y:&forall; X:Type, X
-&gt; X) =&gt; y x x</TT>.<BR>
<BR>
<!--TOC subsubsection I have two proofs of the same proposition. Can I prove they are equal?-->

<H4 CLASS="subsubsection"><A NAME="htoc45">38</A>&nbsp;&nbsp;I have two proofs of the same proposition. Can I prove they are equal?</H4><!--SEC END -->

In the base <SPAN STYLE="font-variant:small-caps">Coq</SPAN> system, the answer is generally no. However, if
classical logic is set, the answer is yes for propositions in <TT>Prop</TT>.
The answer is also yes if proof irrelevance holds (see question
<A HREF="#proof-irrelevance">33</A>).<BR>
<BR>
There are also &#8220;simple enough&#8221; propositions for which you can prove
the equality without requiring any extra axioms. This is typically
the case for propositions defined deterministically as a first-order
inductive predicate on decidable sets. See for instance in question
<A HREF="#le-uniqueness">138</A> an axiom-free proof of the unicity of the proofs of
the proposition <TT>le m n</TT> (less or equal on <TT>nat</TT>).<BR>
<BR>
<!--TOC subsubsection I have two proofs of an equality statement. Can I prove they are 
equal?-->

<H4 CLASS="subsubsection"><A NAME="htoc46">39</A>&nbsp;&nbsp;I have two proofs of an equality statement. Can I prove they are 
equal?</H4><!--SEC END -->

Yes, if equality is decidable on the domain considered (which
is the case for <TT>nat</TT>, <TT>bool</TT>, etc): see <SPAN STYLE="font-variant:small-caps">Coq</SPAN> file
<CODE>Eqdep_dec.v</CODE>). No otherwise, unless
assuming Streicher's axiom <I>K</I> (see [<A HREF="#HofStr98"><CITE>13</CITE></A>]) or a more general
assumption such as proof-irrelevance (see <A HREF="#proof-irrelevance">33</A>) or
classical logic.<BR>
<BR>
All of these statements can be found in file <A HREF="http://coq.inria.fr/library/Coq.Logic.Eqdep.html
"><TT>Eqdep.v</TT></A>.<BR>
<BR>
<!--TOC subsubsection Can I prove that the second components of equal dependent
pairs are equal?-->

<H4 CLASS="subsubsection"><A NAME="htoc47">40</A>&nbsp;&nbsp;Can I prove that the second components of equal dependent
pairs are equal?</H4><!--SEC END -->

The answer is the same as for proofs of equality
statements. It is provable if equality on the domain of the first
component is decidable (look at <CODE>inj_right_pair</CODE> from file
<A HREF="http://coq.inria.fr/library/Coq.Logic.Eqdep_dec.html
"><TT>Eqdep_dec.v</TT></A>), but not provable in the general
case. However, it is consistent (with the Calculus of Constructions)
to assume it is true. The file <A HREF="http://coq.inria.fr/library/Coq.Logic.Eqdep.html
"><TT>Eqdep.v</TT></A> actually
provides an axiom (equivalent to Streicher's axiom <I>K</I>) which entails
the result (look at <CODE>inj_pair2</CODE> in <A HREF="http://coq.inria.fr/library/Coq.Logic.Eqdep.html
"><TT>Eqdep.v</TT></A>).<BR>
<BR>
<!--TOC subsection Impredicativity-->

<H3 CLASS="subsection"><A NAME="htoc48">5.3</A>&nbsp;&nbsp;Impredicativity</H3><!--SEC END -->

<!--TOC subsubsection Why <TT>injection</TT> does not work on impredicative <TT>Set</TT>?-->

<H4 CLASS="subsubsection"><A NAME="htoc49">41</A>&nbsp;&nbsp;Why <TT>injection</TT> does not work on impredicative <TT>Set</TT>?</H4><!--SEC END -->

E.g. in this case (this occurs only in the <TT>Set</TT>-impredicative
 variant of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>):<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;I&nbsp;:&nbsp;Type&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;intro&nbsp;:&nbsp;forall&nbsp;k:Set,&nbsp;k&nbsp;-&gt;&nbsp;I.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;eq_jdef&nbsp;:&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y:nat,&nbsp;intro&nbsp;_&nbsp;x&nbsp;=&nbsp;intro&nbsp;_&nbsp;y&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;y.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;x&nbsp;y&nbsp;H;&nbsp;injection&nbsp;H.</TT><BR>
</DIV>
<BR>
<BR>
Injectivity of constructors is restricted to predicative types. If
injectivity on large inductive types were not restricted, we would be
allowed to derive an inconsistency (e.g. following the lines of
Burali-Forti paradox). The question remains open whether injectivity
is consistent on some large inductive types not expressive enough to
encode known paradoxes (such as type I above).<BR>
<BR>
<!--TOC subsubsection What is a &#8220;large inductive definition&#8221;?-->

<H4 CLASS="subsubsection"><A NAME="htoc50">42</A>&nbsp;&nbsp;What is a &#8220;large inductive definition&#8221;?</H4><!--SEC END -->

An inductive definition in <TT>Prop</TT> or <TT>Set</TT> is called large
if its constructors embed sets or propositions. As an example, here is
a large inductive type:<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;sigST&nbsp;(P:Set&nbsp;-&gt;&nbsp;Set)&nbsp;:&nbsp;Type&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;existST&nbsp;:&nbsp;forall&nbsp;X:Set,&nbsp;P&nbsp;X&nbsp;-&gt;&nbsp;sigST&nbsp;P.</TT><BR>
</DIV>
<BR>
<BR>
In the <TT>Set</TT> impredicative variant of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, large inductive
definitions in <TT>Set</TT> have restricted elimination schemes to
prevent inconsistencies. Especially, projecting the set or the
proposition content of a large inductive definition is forbidden. If
it were allowed, it would be possible to encode e.g. Burali-Forti
paradox [<A HREF="#Gir70"><CITE>10</CITE></A><CITE>, </CITE><A HREF="#Coq85"><CITE>5</CITE></A>].<BR>
<BR>
<!--TOC section Talkin' with the Rooster-->

<H2 CLASS="section"><A NAME="htoc51">6</A>&nbsp;&nbsp;Talkin' with the Rooster</H2><!--SEC END -->

<!--TOC subsection My goal is ..., how can I prove it?-->

<H3 CLASS="subsection"><A NAME="htoc52">6.1</A>&nbsp;&nbsp;My goal is ..., how can I prove it?</H3><!--SEC END -->

<!--TOC subsubsection My goal is a conjunction, how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc53">43</A>&nbsp;&nbsp;My goal is a conjunction, how can I prove it?</H4><!--SEC END -->

Use some theorem or assumption or use the <TT>split</TT> tactic.

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B:Prop,&nbsp;A-&gt;B-&gt;&nbsp;A/\B.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;split.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>split.</I></TT><BR>
<TT><I>&nbsp;assumption.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My goal contains a conjunction as an hypothesis, how can I use it?-->

<H4 CLASS="subsubsection"><A NAME="htoc54">44</A>&nbsp;&nbsp;My goal contains a conjunction as an hypothesis, how can I use it?</H4><!--SEC END -->

If you want to decompose your hypothesis into other hypothesis you can use the <TT>decompose</TT> tactic:<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B:Prop,&nbsp;A/\B-&gt;&nbsp;B.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;/\&nbsp;B&nbsp;-&gt;&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;decompose&nbsp;[and]&nbsp;H.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>decompose&nbsp;[and]&nbsp;H.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm0&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My goal is a disjunction, how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc55">45</A>&nbsp;&nbsp;My goal is a disjunction, how can I prove it?</H4><!--SEC END -->

You can prove the left part or the right part of the disjunction using
<TT>left</TT> or <TT>right</TT> tactics. If you want to do a classical
reasoning step, use the <TT>classic</TT> axiom to prove the right part with the assumption
that the left part of the disjunction is false.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B:Prop,&nbsp;A-&gt;&nbsp;A\/B.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;\/&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;\/&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;left.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>left.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm1&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
An example using classical reasoning:<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Classical.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Ltac&nbsp;classical_right&nbsp;:=&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;match&nbsp;goal&nbsp;with&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;|&nbsp;_:_&nbsp;|-?X1&nbsp;\/&nbsp;_&nbsp;=&gt;&nbsp;(elim&nbsp;(classic&nbsp;X1);intro;[left;trivial|right])</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;end.</TT><BR>
<TT><I>classical_right&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Ltac&nbsp;classical_left&nbsp;:=&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;match&nbsp;goal&nbsp;with&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;|&nbsp;_:_&nbsp;|-&nbsp;_&nbsp;\/?X1&nbsp;=&gt;&nbsp;(elim&nbsp;(classic&nbsp;X1);intro;[right;trivial|left])</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;end.</TT><BR>
<TT><I>classical_left&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B:Prop,&nbsp;(~A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A\/B.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop,&nbsp;(~&nbsp;A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;A&nbsp;\/&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;~&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;\/&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;classical_right.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;~&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;~&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>classical_right.</I></TT><BR>
<TT><I>auto.</I></TT><BR>
<TT><I>Unnamed_thm2&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My goal is an universally quantified statement, how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc56">46</A>&nbsp;&nbsp;My goal is an universally quantified statement, how can I prove it?</H4><!--SEC END -->

Use some theorem or assumption or introduce the quantified variable in
the context using the <TT>intro</TT> tactic. If there are several
variables you can use the <TT>intros</TT> tactic. A good habit is to
provide names for these variables: <SPAN STYLE="font-variant:small-caps">Coq</SPAN> will do it anyway, but such
automatic naming decreases legibility and robustness.<BR>
<BR>
<!--TOC subsubsection My goal is an existential, how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc57">47</A>&nbsp;&nbsp;My goal is an existential, how can I prove it?</H4><!--SEC END -->

Use some theorem or assumption or exhibit the witness using the <TT>exists</TT> tactic.

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;exists&nbsp;x:nat,&nbsp;forall&nbsp;y,&nbsp;x+y=y.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;exists&nbsp;x&nbsp;:&nbsp;nat,&nbsp;forall&nbsp;y&nbsp;:&nbsp;nat,&nbsp;x&nbsp;+&nbsp;y&nbsp;=&nbsp;y</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;exists&nbsp;0.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;y&nbsp;:&nbsp;nat,&nbsp;0&nbsp;+&nbsp;y&nbsp;=&nbsp;y</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;0&nbsp;+&nbsp;y&nbsp;=&nbsp;y</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>exists&nbsp;0.</I></TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>auto.</I></TT><BR>
<TT><I>Unnamed_thm3&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My goal is solvable by some lemma, how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc58">48</A>&nbsp;&nbsp;My goal is solvable by some lemma, how can I prove it?</H4><!--SEC END -->

Just use the <TT>apply</TT> tactic.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;mylemma&nbsp;:&nbsp;forall&nbsp;x,&nbsp;x+0&nbsp;=&nbsp;x.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;:&nbsp;nat,&nbsp;x&nbsp;+&nbsp;0&nbsp;=&nbsp;x</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>auto.</I></TT><BR>
<TT><I>mylemma&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;3+0&nbsp;=&nbsp;3.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;3&nbsp;+&nbsp;0&nbsp;=&nbsp;3</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;mylemma.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>apply&nbsp;mylemma.</I></TT><BR>
<TT><I>Unnamed_thm&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My goal contains False as an hypothesis, how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc59">49</A>&nbsp;&nbsp;My goal contains False as an hypothesis, how can I prove it?</H4><!--SEC END -->

You can use the <TT>contradiction</TT> or <TT>intuition</TT> tactics.<BR>
<BR>
<!--TOC subsubsection My goal is an equality of two convertible terms, how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc60">50</A>&nbsp;&nbsp;My goal is an equality of two convertible terms, how can I prove it?</H4><!--SEC END -->

Just use the <TT>reflexivity</TT> tactic.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;x,&nbsp;0+x&nbsp;=&nbsp;x.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;:&nbsp;nat,&nbsp;0&nbsp;+&nbsp;x&nbsp;=&nbsp;x</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;0&nbsp;+&nbsp;x&nbsp;=&nbsp;x</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;reflexivity.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>reflexivity.</I></TT><BR>
<TT><I>Unnamed_thm0&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My goal is a <TT>let x := a in ...</TT>, how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc61">51</A>&nbsp;&nbsp;My goal is a <TT>let x := a in ...</TT>, how can I prove it?</H4><!--SEC END -->

Just use the <TT>intro</TT> tactic.<BR>
<BR>
<!--TOC subsubsection My goal is a <TT>let (a, ..., b) := c in</TT>, how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc62">52</A>&nbsp;&nbsp;My goal is a <TT>let (a, ..., b) := c in</TT>, how can I prove it?</H4><!--SEC END -->

Just use the <TT>destruct</TT> c as (a,...,b) tactic.<BR>
<BR>
<!--TOC subsubsection My goal contains some existential hypotheses, how can I use it?-->

<H4 CLASS="subsubsection"><A NAME="htoc63">53</A>&nbsp;&nbsp;My goal contains some existential hypotheses, how can I use it?</H4><!--SEC END -->

You can use the tactic <TT>elim</TT> with you hypotheses as an argument.<BR>
<BR>
<!--TOC subsubsection My goal contains some existential hypotheses, how can I use it and decompose my knowledge about this new thing into different hypotheses?-->

<H4 CLASS="subsubsection"><A NAME="htoc64">54</A>&nbsp;&nbsp;My goal contains some existential hypotheses, how can I use it and decompose my knowledge about this new thing into different hypotheses?</H4><!--SEC END -->

<PRE CLASS="verbatim">
Ltac DecompEx H P := elim H;intro P;intro TO;decompose [and] TO;clear TO;clear H.
</PRE>
<!--TOC subsubsection My goal is an equality, how can I swap the left and right hand terms?-->

<H4 CLASS="subsubsection"><A NAME="htoc65">55</A>&nbsp;&nbsp;My goal is an equality, how can I swap the left and right hand terms?</H4><!--SEC END -->

Just use the <TT>symmetry</TT> tactic.

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;nat,&nbsp;x=y&nbsp;-&gt;&nbsp;y=x.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;nat,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;x</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;x</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;symmetry.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>symmetry&nbsp;&nbsp;in&nbsp;|-&nbsp;*.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm1&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My hypothesis is an equality, how can I swap the left and right hand terms?-->

<H4 CLASS="subsubsection"><A NAME="htoc66">56</A>&nbsp;&nbsp;My hypothesis is an equality, how can I swap the left and right hand terms?</H4><!--SEC END -->

Just use the <TT>symmetryin</TT> tactic.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;nat,&nbsp;x=y&nbsp;-&gt;&nbsp;y=x.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;:&nbsp;nat,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;x</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;x</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;symmetry&nbsp;in&nbsp;H.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;y&nbsp;=&nbsp;x</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;x</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>symmetry&nbsp;&nbsp;in&nbsp;H.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm2&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My goal is an equality, how can I prove it by transitivity?-->

<H4 CLASS="subsubsection"><A NAME="htoc67">57</A>&nbsp;&nbsp;My goal is an equality, how can I prove it by transitivity?</H4><!--SEC END -->

Just use the <TT>transitivity</TT> tactic.

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;nat,&nbsp;x=y&nbsp;-&gt;&nbsp;y=z&nbsp;-&gt;&nbsp;x=z.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;nat,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;z&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;transitivity&nbsp;y.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>transitivity&nbsp;y.</I></TT><BR>
<TT><I>&nbsp;assumption.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm3&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My goal would be solvable using <TT>apply;assumption</TT> if it would not create meta-variables, how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc68">58</A>&nbsp;&nbsp;My goal would be solvable using <TT>apply;assumption</TT> if it would not create meta-variables, how can I prove it?</H4><!--SEC END -->

You can use <TT>eapply yourtheorem;eauto</TT> but it won't work in all cases ! (for example if more than one hypothesis match one of the subgoals generated by <TT>eapply</TT>) so you should rather use <TT>try solve [eapply yourtheorem;eauto]</TT>, otherwise some metavariables may be incorrectly instantiated.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;trans&nbsp;:&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;nat,&nbsp;x=y&nbsp;-&gt;&nbsp;y=z&nbsp;-&gt;&nbsp;x=z.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;nat,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;z&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;transitivity&nbsp;y;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>transitivity&nbsp;y;&nbsp;assumption.</I></TT><BR>
<TT><I>trans&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;nat,&nbsp;x=y&nbsp;-&gt;&nbsp;y=z&nbsp;-&gt;&nbsp;x=z.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;:&nbsp;nat,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;z&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;eapply&nbsp;trans;eauto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>&nbsp;eapply&nbsp;trans;&nbsp;&nbsp;eauto.</I></TT><BR>
<TT><I>Unnamed_thm4&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;t&nbsp;:&nbsp;nat,&nbsp;x=y&nbsp;-&gt;&nbsp;x=t&nbsp;-&gt;&nbsp;y=z&nbsp;-&gt;&nbsp;x=z.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;t&nbsp;:&nbsp;nat,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;t&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;z&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;eapply&nbsp;trans;eauto.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;t&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Undo.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;eapply&nbsp;trans.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;?47</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;?47&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;H.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>&nbsp;eapply&nbsp;trans.</I></TT><BR>
<TT><I>&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;apply&nbsp;H.</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;auto.</I></TT><BR>
<TT><I>Unnamed_thm5&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;t&nbsp;:&nbsp;nat,&nbsp;x=y&nbsp;-&gt;&nbsp;x=t&nbsp;-&gt;&nbsp;y=z&nbsp;-&gt;&nbsp;x=z.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;x&nbsp;y&nbsp;z&nbsp;t&nbsp;:&nbsp;nat,&nbsp;x&nbsp;=&nbsp;y&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;t&nbsp;-&gt;&nbsp;y&nbsp;=&nbsp;z&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;eapply&nbsp;trans;eauto.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;t&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Undo.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;try&nbsp;solve&nbsp;[eapply&nbsp;trans;eauto].</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;eapply&nbsp;trans.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;?54</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;?54&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;H.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;x&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;y&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;z&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;t&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;x&nbsp;=&nbsp;y</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;x&nbsp;=&nbsp;t</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;z</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>try&nbsp;(solve&nbsp;[&nbsp;&nbsp;eapply&nbsp;trans;&nbsp;&nbsp;eauto&nbsp;]).</I></TT><BR>
<TT><I>&nbsp;eapply&nbsp;trans.</I></TT><BR>
<TT><I>&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;apply&nbsp;H.</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;auto.</I></TT><BR>
<TT><I>Unnamed_thm6&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My goal is solvable by some lemma within a set of lemmas and I don't want to remember which one, how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc69">59</A>&nbsp;&nbsp;My goal is solvable by some lemma within a set of lemmas and I don't want to remember which one, how can I prove it?</H4><!--SEC END -->

You can use a what is called a hints' base.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;ZArith.</TT><BR>
<TT><I>Coq&nbsp;&lt;&nbsp;</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Ring.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Open&nbsp;Local&nbsp;Scope&nbsp;Z_scope.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;toto1&nbsp;:&nbsp;1+1&nbsp;=&nbsp;2.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;1&nbsp;+&nbsp;1&nbsp;=&nbsp;2</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;ring.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>&nbsp;ring.</I></TT><BR>
<TT><I>toto1&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;toto2&nbsp;:&nbsp;2+2&nbsp;=&nbsp;4.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;2&nbsp;+&nbsp;2&nbsp;=&nbsp;4</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;ring.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>&nbsp;ring.</I></TT><BR>
<TT><I>toto2&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;toto3&nbsp;:&nbsp;2+1&nbsp;=&nbsp;3.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;2&nbsp;+&nbsp;1&nbsp;=&nbsp;3</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;ring.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>&nbsp;ring.</I></TT><BR>
<TT><I>toto3&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Hint&nbsp;Resolve&nbsp;toto1&nbsp;toto2&nbsp;toto3&nbsp;:&nbsp;mybase.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;2+(1+1)=4.&nbsp;</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;2&nbsp;+&nbsp;(1&nbsp;+&nbsp;1)&nbsp;=&nbsp;4</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;auto&nbsp;with&nbsp;mybase.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>auto&nbsp;with&nbsp;mybase.</I></TT><BR>
<TT><I>Unnamed_thm7&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My goal is one of the hypotheses, how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc70">60</A>&nbsp;&nbsp;My goal is one of the hypotheses, how can I prove it?</H4><!--SEC END -->

Use the <TT>assumption</TT> tactic.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;1=1&nbsp;-&gt;&nbsp;1=1.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;1&nbsp;=&nbsp;1&nbsp;-&gt;&nbsp;1&nbsp;=&nbsp;1</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intro.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;1&nbsp;=&nbsp;1</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;1&nbsp;=&nbsp;1</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intro.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm8&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My goal appears twice in the hypotheses and I want to choose which one is used, how can I do it?-->

<H4 CLASS="subsubsection"><A NAME="htoc71">61</A>&nbsp;&nbsp;My goal appears twice in the hypotheses and I want to choose which one is used, how can I do it?</H4><!--SEC END -->

Use the <TT>exact</TT> tactic.

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;1=1&nbsp;-&gt;&nbsp;1=1&nbsp;-&gt;&nbsp;1=1.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;1&nbsp;=&nbsp;1&nbsp;-&gt;&nbsp;1&nbsp;=&nbsp;1&nbsp;-&gt;&nbsp;1&nbsp;=&nbsp;1</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;1&nbsp;=&nbsp;1</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;1&nbsp;=&nbsp;1</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;1&nbsp;=&nbsp;1</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;exact&nbsp;H0.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>exact&nbsp;H0.</I></TT><BR>
<TT><I>Unnamed_thm9&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection What can be the difference between applying one hypothesis or another in the context of the last question?-->

<H4 CLASS="subsubsection"><A NAME="htoc72">62</A>&nbsp;&nbsp;What can be the difference between applying one hypothesis or another in the context of the last question?</H4><!--SEC END -->

From a proof point of view it is equivalent but if you want to extract
a program from your proof, the two hypotheses can lead to different
programs.<BR>
<BR>
<!--TOC subsubsection My goal is a propositional tautology, how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc73">63</A>&nbsp;&nbsp;My goal is a propositional tautology, how can I prove it?</H4><!--SEC END -->

Just use the <TT>tauto</TT> tactic.

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B:Prop,&nbsp;A-&gt;&nbsp;(A\/B)&nbsp;/\&nbsp;A.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;-&gt;&nbsp;(A&nbsp;\/&nbsp;B)&nbsp;/\&nbsp;A</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;(A&nbsp;\/&nbsp;B)&nbsp;/\&nbsp;A</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;tauto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>&nbsp;tauto.</I></TT><BR>
<TT><I>Unnamed_thm10&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My goal is a first order formula, how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc74">64</A>&nbsp;&nbsp;My goal is a first order formula, how can I prove it?</H4><!--SEC END -->

Just use the semi-decision tactic: <TT>firstorder</TT>.<BR>
<BR>
<!--TOC subsubsection My goal is solvable by a sequence of rewrites, how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc75">65</A>&nbsp;&nbsp;My goal is solvable by a sequence of rewrites, how can I prove it?</H4><!--SEC END -->

Just use the <TT>congruence</TT> tactic.

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;a&nbsp;b&nbsp;c&nbsp;d&nbsp;e,&nbsp;a=d&nbsp;-&gt;&nbsp;b=e&nbsp;-&gt;&nbsp;c+b=d&nbsp;-&gt;&nbsp;c+e=a.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;a&nbsp;b&nbsp;c&nbsp;d&nbsp;e&nbsp;:&nbsp;Z,&nbsp;a&nbsp;=&nbsp;d&nbsp;-&gt;&nbsp;b&nbsp;=&nbsp;e&nbsp;-&gt;&nbsp;c&nbsp;+&nbsp;b&nbsp;=&nbsp;d&nbsp;-&gt;&nbsp;c&nbsp;+&nbsp;e&nbsp;=&nbsp;a</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;a&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;b&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;c&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;d&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;e&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;a&nbsp;=&nbsp;d</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;b&nbsp;=&nbsp;e</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;c&nbsp;+&nbsp;b&nbsp;=&nbsp;d</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;c&nbsp;+&nbsp;e&nbsp;=&nbsp;a</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;congruence.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>&nbsp;congruence.</I></TT><BR>
<TT><I>Unnamed_thm11&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My goal is a disequality solvable by a sequence of rewrites, how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc76">66</A>&nbsp;&nbsp;My goal is a disequality solvable by a sequence of rewrites, how can I prove it?</H4><!--SEC END -->

Just use the <TT>congruence</TT> tactic.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;a&nbsp;b&nbsp;c&nbsp;d,&nbsp;a&lt;&gt;d&nbsp;-&gt;&nbsp;b=a&nbsp;-&gt;&nbsp;d=c+b&nbsp;-&gt;&nbsp;b&lt;&gt;c+b.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;a&nbsp;b&nbsp;c&nbsp;d&nbsp;:&nbsp;Z,&nbsp;a&nbsp;&lt;&gt;&nbsp;d&nbsp;-&gt;&nbsp;b&nbsp;=&nbsp;a&nbsp;-&gt;&nbsp;d&nbsp;=&nbsp;c&nbsp;+&nbsp;b&nbsp;-&gt;&nbsp;b&nbsp;&lt;&gt;&nbsp;c&nbsp;+&nbsp;b</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;a&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;b&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;c&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;d&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;a&nbsp;&lt;&gt;&nbsp;d</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;b&nbsp;=&nbsp;a</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;d&nbsp;=&nbsp;c&nbsp;+&nbsp;b</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;b&nbsp;&lt;&gt;&nbsp;c&nbsp;+&nbsp;b</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;congruence.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>&nbsp;congruence.</I></TT><BR>
<TT><I>Unnamed_thm12&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My goal is an equality on some ring (e.g. natural numbers), how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc77">67</A>&nbsp;&nbsp;My goal is an equality on some ring (e.g. natural numbers), how can I prove it?</H4><!--SEC END -->

Just use the <TT>ring</TT> tactic.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;ZArith.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Ring.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Open&nbsp;Local&nbsp;Scope&nbsp;Z_scope.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;a&nbsp;b&nbsp;:&nbsp;Z,&nbsp;(a+b)*(a+b)&nbsp;=&nbsp;a*a&nbsp;+&nbsp;2*a*b&nbsp;+&nbsp;b*b.&nbsp;</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;a&nbsp;b&nbsp;:&nbsp;Z,&nbsp;(a&nbsp;+&nbsp;b)&nbsp;*&nbsp;(a&nbsp;+&nbsp;b)&nbsp;=&nbsp;a&nbsp;*&nbsp;a&nbsp;+&nbsp;2&nbsp;*&nbsp;a&nbsp;*&nbsp;b&nbsp;+&nbsp;b&nbsp;*&nbsp;b</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;a&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;b&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;(a&nbsp;+&nbsp;b)&nbsp;*&nbsp;(a&nbsp;+&nbsp;b)&nbsp;=&nbsp;a&nbsp;*&nbsp;a&nbsp;+&nbsp;2&nbsp;*&nbsp;a&nbsp;*&nbsp;b&nbsp;+&nbsp;b&nbsp;*&nbsp;b</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;ring.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>&nbsp;ring.</I></TT><BR>
<TT><I>Unnamed_thm13&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My goal is an equality on some field (e.g. real numbers), how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc78">68</A>&nbsp;&nbsp;My goal is an equality on some field (e.g. real numbers), how can I prove it?</H4><!--SEC END -->

Just use the <TT>field</TT> tactic.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Reals.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Ring.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Open&nbsp;Local&nbsp;Scope&nbsp;R_scope.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;a&nbsp;b&nbsp;:&nbsp;R,&nbsp;b*a&lt;&gt;0&nbsp;-&gt;&nbsp;(a/b)&nbsp;*&nbsp;(b/a)&nbsp;=&nbsp;1.&nbsp;</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;a&nbsp;b&nbsp;:&nbsp;R,&nbsp;b&nbsp;*&nbsp;a&nbsp;&lt;&gt;&nbsp;0&nbsp;-&gt;&nbsp;a&nbsp;/&nbsp;b&nbsp;*&nbsp;(b&nbsp;/&nbsp;a)&nbsp;=&nbsp;1</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;a&nbsp;:&nbsp;R</I></TT><BR>
<TT><I>&nbsp;&nbsp;b&nbsp;:&nbsp;R</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;b&nbsp;*&nbsp;a&nbsp;&lt;&gt;&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;a&nbsp;/&nbsp;b&nbsp;*&nbsp;(b&nbsp;/&nbsp;a)&nbsp;=&nbsp;1</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;field.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;a&nbsp;:&nbsp;R</I></TT><BR>
<TT><I>&nbsp;&nbsp;b&nbsp;:&nbsp;R</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;b&nbsp;*&nbsp;a&nbsp;&lt;&gt;&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;a&nbsp;&lt;&gt;&nbsp;0&nbsp;/\&nbsp;b&nbsp;&lt;&gt;&nbsp;0</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Toplevel&nbsp;input,&nbsp;characters&nbsp;0-10</I></TT><BR>
<TT><I>&gt;&nbsp;assumption.</I></TT><BR>
<TT><I>&gt;&nbsp;^^^^^^^^^^</I></TT><BR>
<TT><I>User&nbsp;error:&nbsp;No&nbsp;such&nbsp;assumption</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>&nbsp;field.</I></TT><BR>
<TT><I>&lt;Your&nbsp;Tactic&nbsp;Text&nbsp;here&gt;</I></TT><BR>
<TT><I>User&nbsp;error:&nbsp;Attempt&nbsp;to&nbsp;save&nbsp;an&nbsp;incomplete&nbsp;proof</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My goal is an inequality on integers in Presburger's arithmetic (an expression build from +,-,constants and variables), how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc79">69</A>&nbsp;&nbsp;My goal is an inequality on integers in Presburger's arithmetic (an expression build from +,-,constants and variables), how can I prove it?</H4><!--SEC END -->


<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;ZArith.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Omega.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Open&nbsp;Local&nbsp;Scope&nbsp;Z_scope.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;a&nbsp;:&nbsp;Z,&nbsp;a&gt;0&nbsp;-&gt;&nbsp;a+a&nbsp;&gt;&nbsp;a.&nbsp;</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;a&nbsp;:&nbsp;Z,&nbsp;a&nbsp;&gt;&nbsp;0&nbsp;-&gt;&nbsp;a&nbsp;+&nbsp;a&nbsp;&gt;&nbsp;a</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;a&nbsp;:&nbsp;Z</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;a&nbsp;&gt;&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;a&nbsp;+&nbsp;a&nbsp;&gt;&nbsp;a</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;omega.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>&nbsp;omega.</I></TT><BR>
<TT><I>Unnamed_thm15&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection My goal is an equation solvable using equational hypothesis on some ring (e.g. natural numbers), how can I prove it?-->

<H4 CLASS="subsubsection"><A NAME="htoc80">70</A>&nbsp;&nbsp;My goal is an equation solvable using equational hypothesis on some ring (e.g. natural numbers), how can I prove it?</H4><!--SEC END -->

You need the <TT>gb</TT> tactic (see Loïc Pottier's homepage).<BR>
<BR>
<!--TOC subsection Tactics usage-->

<H3 CLASS="subsection"><A NAME="htoc81">6.2</A>&nbsp;&nbsp;Tactics usage</H3><!--SEC END -->

<!--TOC subsubsection I want to state a fact that I will use later as an hypothesis, how can I do it?-->

<H4 CLASS="subsubsection"><A NAME="htoc82">71</A>&nbsp;&nbsp;I want to state a fact that I will use later as an hypothesis, how can I do it?</H4><!--SEC END -->

If you want to use forward reasoning (first proving the fact and then
using it) you just need to use the <TT>assert</TT> tactic. If you want to use
backward reasoning (proving your goal using an assumption and then
proving the assumption) use the <TT>cut</TT> tactic.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B&nbsp;C&nbsp;D&nbsp;:&nbsp;Prop,&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;(B-&gt;C)&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;C.&nbsp;</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;C&nbsp;:&nbsp;Prop,&nbsp;Prop&nbsp;-&gt;&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;(B&nbsp;-&gt;&nbsp;C)&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assert&nbsp;(A-&gt;C).</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intro;apply&nbsp;H0;apply&nbsp;H;assumption.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H2&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;H2.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H2&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>assert&nbsp;(A&nbsp;-&gt;&nbsp;C).</I></TT><BR>
<TT><I>&nbsp;intro;&nbsp;apply&nbsp;H0;&nbsp;apply&nbsp;H;&nbsp;assumption.</I></TT><BR>
<TT><I>apply&nbsp;H2.</I></TT><BR>
<TT><I>&nbsp;&nbsp;assumption.</I></TT><BR>
<TT><I>Unnamed_thm16&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B&nbsp;C&nbsp;D&nbsp;:&nbsp;Prop,&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;(B-&gt;C)&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;C.&nbsp;</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;C&nbsp;:&nbsp;Prop,&nbsp;Prop&nbsp;-&gt;&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;-&gt;&nbsp;(B&nbsp;-&gt;&nbsp;C)&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;cut&nbsp;(A-&gt;C).</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;(A&nbsp;-&gt;&nbsp;C)&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intro.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H2&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;C</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;H2;assumption.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;D&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;-&gt;&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intro;apply&nbsp;H0;apply&nbsp;H;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>cut&nbsp;(A&nbsp;-&gt;&nbsp;C).</I></TT><BR>
<TT><I>&nbsp;intro.</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;apply&nbsp;H2;&nbsp;assumption.</I></TT><BR>
<TT><I>intro;&nbsp;apply&nbsp;H0;&nbsp;apply&nbsp;H;&nbsp;assumption.</I></TT><BR>
<TT><I>Unnamed_thm17&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection I want to state a fact that I will use later as an hypothesis and prove it later, how can I do it?-->

<H4 CLASS="subsubsection"><A NAME="htoc83">72</A>&nbsp;&nbsp;I want to state a fact that I will use later as an hypothesis and prove it later, how can I do it?</H4><!--SEC END -->

You can use <TT>cut</TT> followed by <TT>intro</TT> or you can use the following <SPAN STYLE="font-variant:small-caps">Ltac</SPAN> command:
<PRE CLASS="verbatim">
Ltac assert_later t := cut t;[intro|idtac]. 
</PRE>
<!--TOC subsubsection What is the difference between <TT>Qed</TT> and <TT>Defined</TT>?-->

<H4 CLASS="subsubsection"><A NAME="htoc84">73</A>&nbsp;&nbsp;What is the difference between <TT>Qed</TT> and <TT>Defined</TT>?</H4><!--SEC END -->

These two commands perform type checking, but when <TT>Defined</TT> is used the new definition is set as transparent, otherwise it is defined as opaque (see <A HREF="#opaque">169</A>).<BR>
<BR>
<!--TOC subsubsection How can I know what a tactic does?-->

<H4 CLASS="subsubsection"><A NAME="htoc85">74</A>&nbsp;&nbsp;How can I know what a tactic does?</H4><!--SEC END -->

You can use the <TT>info</TT> command.<BR>
<BR>
<!--TOC subsubsection Why <TT>auto</TT> does not work? How can I fix it?-->

<H4 CLASS="subsubsection"><A NAME="htoc86">75</A>&nbsp;&nbsp;Why <TT>auto</TT> does not work? How can I fix it?</H4><!--SEC END -->

You can increase the depth of the proof search or add some lemmas in the base of hints.
Perhaps you may need to use <TT>eauto</TT>.<BR>
<BR>
<!--TOC subsubsection What is <TT>eauto</TT>?-->

<H4 CLASS="subsubsection"><A NAME="htoc87">76</A>&nbsp;&nbsp;What is <TT>eauto</TT>?</H4><!--SEC END -->

This is the same tactic as <TT>auto</TT>, but it relies on <TT>eapply</TT> instead of <TT>apply</TT>.<BR>
<BR>
<!--TOC subsubsection How can I speed up <TT>auto</TT>?-->

<H4 CLASS="subsubsection"><A NAME="htoc88">77</A>&nbsp;&nbsp;How can I speed up <TT>auto</TT>?</H4><!--SEC END -->

You can use <TT>info </TT><TT>auto</TT>to replace <TT>auto</TT> by the tactics it generates.
You can split your hint bases into smaller ones.<BR>
<BR>
<!--TOC subsubsection What is the equivalent of <TT>tauto</TT> for classical logic?-->

<H4 CLASS="subsubsection"><A NAME="htoc89">78</A>&nbsp;&nbsp;What is the equivalent of <TT>tauto</TT> for classical logic?</H4><!--SEC END -->

Currently there are no equivalent tactic for classical logic. You can use Gödel's &#8220;not not&#8221; translation.<BR>
<BR>
<!--TOC subsubsection I want to replace some term with another in the goal, how can I do it?-->

<H4 CLASS="subsubsection"><A NAME="htoc90">79</A>&nbsp;&nbsp;I want to replace some term with another in the goal, how can I do it?</H4><!--SEC END -->

If one of your hypothesis (say <TT>H</TT>) states that the terms are equal you can use the <TT>rewrite</TT> tactic. Otherwise you can use the <TT>replace</TT> <TT>with</TT> tactic. <BR>
<BR>
<!--TOC subsubsection I want to replace some term with another in an hypothesis, how can I do it?-->

<H4 CLASS="subsubsection"><A NAME="htoc91">80</A>&nbsp;&nbsp;I want to replace some term with another in an hypothesis, how can I do it?</H4><!--SEC END -->

You can use the <TT>rewrite</TT> <TT>in</TT> tactic.<BR>
<BR>
<!--TOC subsubsection I want to replace some symbol with its definition, how can I do it?-->

<H4 CLASS="subsubsection"><A NAME="htoc92">81</A>&nbsp;&nbsp;I want to replace some symbol with its definition, how can I do it?</H4><!--SEC END -->

You can use the <TT>unfold</TT> tactic.<BR>
<BR>
<!--TOC subsubsection How can I reduce some term?-->

<H4 CLASS="subsubsection"><A NAME="htoc93">82</A>&nbsp;&nbsp;How can I reduce some term?</H4><!--SEC END -->

You can use the <TT>simpl</TT> tactic.<BR>
<BR>
<!--TOC subsubsection How can I declare a shortcut for some term?-->

<H4 CLASS="subsubsection"><A NAME="htoc94">83</A>&nbsp;&nbsp;How can I declare a shortcut for some term?</H4><!--SEC END -->

You can use the <TT>set</TT> or <TT>pose</TT> tactics.<BR>
<BR>
<!--TOC subsubsection How can I perform case analysis?-->

<H4 CLASS="subsubsection"><A NAME="htoc95">84</A>&nbsp;&nbsp;How can I perform case analysis?</H4><!--SEC END -->

You can use the <TT>case</TT> or <TT>destruct</TT> tactics.<BR>
<BR>
<!--TOC subsubsection Why should I name my intros?-->

<H4 CLASS="subsubsection"><A NAME="htoc96">85</A>&nbsp;&nbsp;Why should I name my intros?</H4><!--SEC END -->

When you use the <TT>intro</TT> tactic you don't have to give a name to your
hypothesis. If you do so the name will be generated by <SPAN STYLE="font-variant:small-caps">Coq</SPAN> but your
scripts may be less robust. If you add some hypothesis to your theorem
(or change their order), you will have to change your proof to adapt
to the new names.<BR>
<BR>
<!--TOC subsubsection How can I automatize the naming?-->

<H4 CLASS="subsubsection"><A NAME="htoc97">86</A>&nbsp;&nbsp;How can I automatize the naming?</H4><!--SEC END -->

You can use the <TT>Show Intro.</TT> or <TT>Show Intros.</TT> commands to generate the names and use your editor to generate a fully named <TT>intro</TT> tactic. 
This can be automatized within <TT>xemacs</TT>.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B&nbsp;C&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C&nbsp;-&gt;&nbsp;A/\B/\C.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;C&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;C&nbsp;-&gt;&nbsp;A&nbsp;/\&nbsp;B&nbsp;/\&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Show&nbsp;Intros.</TT><BR>
<TT><I>A&nbsp;B&nbsp;C&nbsp;H&nbsp;H0&nbsp;H1</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;(*</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;A&nbsp;B&nbsp;C&nbsp;H&nbsp;H0</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;H1</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;*)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;intros&nbsp;A&nbsp;B&nbsp;C&nbsp;H&nbsp;H0&nbsp;H1.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;/\&nbsp;B&nbsp;/\&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;repeat&nbsp;split;assumption.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros&nbsp;A&nbsp;B&nbsp;C&nbsp;H&nbsp;H0&nbsp;H1.</I></TT><BR>
<TT><I>repeat&nbsp;split;&nbsp;assumption.</I></TT><BR>
<TT><I>Unnamed_thm18&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection I want to automatize the use of some tactic, how can I do it?-->

<H4 CLASS="subsubsection"><A NAME="htoc98">87</A>&nbsp;&nbsp;I want to automatize the use of some tactic, how can I do it?</H4><!--SEC END -->

You need to use the <TT>proof with T</TT> command and add ... at the
end of your sentences.<BR>
<BR>
For instance:

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B&nbsp;C&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;-&gt;&nbsp;B/\C&nbsp;-&gt;&nbsp;A/\B/\C.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;C&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;/\&nbsp;C&nbsp;-&gt;&nbsp;A&nbsp;/\&nbsp;B&nbsp;/\&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof&nbsp;with&nbsp;assumption.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;C&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B&nbsp;/\&nbsp;C</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;/\&nbsp;B&nbsp;/\&nbsp;C</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;split...</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>split...</I></TT><BR>
<TT><I>Unnamed_thm19&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection I want to execute the <TT>p</TT>roof with tactic only if it solves the goal, how can I do it?-->

<H4 CLASS="subsubsection"><A NAME="htoc99">88</A>&nbsp;&nbsp;I want to execute the <TT>p</TT>roof with tactic only if it solves the goal, how can I do it?</H4><!--SEC END -->

You need to use the <TT>try</TT> and <TT>solve</TT> tactics. For instance:

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;ZArith.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Ring.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Open&nbsp;Local&nbsp;Scope&nbsp;Z_scope.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;a&nbsp;b&nbsp;c&nbsp;:&nbsp;Z,&nbsp;a+b=b+a.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;a&nbsp;b&nbsp;:&nbsp;Z,&nbsp;Z&nbsp;-&gt;&nbsp;a&nbsp;+&nbsp;b&nbsp;=&nbsp;b&nbsp;+&nbsp;a</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof&nbsp;with&nbsp;try&nbsp;solve&nbsp;[ring].</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros...</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros...</I></TT><BR>
<TT><I>Unnamed_thm20&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection How can I do the opposite of the <TT>intro</TT> tactic?-->

<H4 CLASS="subsubsection"><A NAME="htoc100">89</A>&nbsp;&nbsp;How can I do the opposite of the <TT>intro</TT> tactic?</H4><!--SEC END -->

You can use the <TT>generalize</TT> tactic.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop,&nbsp;A-&gt;B-&gt;&nbsp;A/\B.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;generalize&nbsp;H.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intro.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;A&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;B&nbsp;:&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;B</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;A</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;A&nbsp;/\&nbsp;B</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>generalize&nbsp;H.</I></TT><BR>
<TT><I>intro.</I></TT><BR>
<TT><I>auto.</I></TT><BR>
<TT><I>Unnamed_thm21&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection One of the hypothesis is an equality between a variable and some term, I want to get rid of this variable, how can I do it?-->

<H4 CLASS="subsubsection"><A NAME="htoc101">90</A>&nbsp;&nbsp;One of the hypothesis is an equality between a variable and some term, I want to get rid of this variable, how can I do it?</H4><!--SEC END -->

You can use the <TT>subst</TT> tactic. This will rewrite the equality everywhere and clear the assumption.<BR>
<BR>
<!--TOC subsubsection What can I do if I get &#8220;<TT>generated subgoal term has metavariables in it </TT>&#8221;?-->

<H4 CLASS="subsubsection"><A NAME="htoc102">91</A>&nbsp;&nbsp;What can I do if I get &#8220;<TT>generated subgoal term has metavariables in it </TT>&#8221;?</H4><!--SEC END -->

You should use the <TT>eapply</TT> tactic, this will generate some goals containing metavariables. <BR>
<BR>
<!--TOC subsubsection How can I instantiate some metavariable?-->

<H4 CLASS="subsubsection"><A NAME="htoc103">92</A>&nbsp;&nbsp;How can I instantiate some metavariable?</H4><!--SEC END -->

Just use the <TT>instantiate</TT> tactic.<BR>
<BR>
<!--TOC subsubsection What is the use of the <TT>pattern</TT> tactic?-->

<H4 CLASS="subsubsection"><A NAME="htoc104">93</A>&nbsp;&nbsp;What is the use of the <TT>pattern</TT> tactic?</H4><!--SEC END -->

The <TT>pattern</TT> tactic transforms the current goal, performing
beta-expansion on all the applications featuring this tactic's
argument. For instance, if the current goal includes a subterm <TT>phi(t)</TT>, then <TT>pattern t</TT> transforms the subterm into <TT>(fun
x:A =&gt; phi(x)) t</TT>. This can be useful when <TT>apply</TT> fails on matching,
to abstract the appropriate terms.<BR>
<BR>
<!--TOC subsubsection What is the difference between assert, cut and generalize?-->

<H4 CLASS="subsubsection"><A NAME="htoc105">94</A>&nbsp;&nbsp;What is the difference between assert, cut and generalize?</H4><!--SEC END -->

PS: Notice for people that are interested in proof rendering that <TT>assert</TT>and <TT>pose</TT> (and <TT>cut</TT>) are not rendered the same as <TT>generalize</TT> (see the
HELM experimental rendering tool at <A HREF="http://helm.cs.unibo.it/library.html"><TT>http://helm.cs.unibo.it</TT></A>, link
HELM, link COQ Online). Indeed <TT>generalize</TT> builds a beta-expanded term
while <TT>assert</TT>, <TT>pose</TT> and <TT>cut</TT> uses a let-in.
<PRE CLASS="verbatim">
  (* Goal is T *)
  generalize (H1 H2).
  (* Goal is A-&gt;T *)
  ... a proof of A-&gt;T ...
</PRE>
is rendered into something like
<PRE CLASS="verbatim">
  (h) ... the proof of A-&gt;T ...
      we proved A-&gt;T
  (h0) by (H1 H2) we proved A
  by (h h0) we proved T
</PRE>while 
<PRE CLASS="verbatim">
  (* Goal is T *)
  assert q := (H1 H2).
  (* Goal is A *)
  ... a proof of A ...
  (* Goal is A |- T *)
  ... a proof of T ...
</PRE>is rendered into something like
<PRE CLASS="verbatim">
  (q) ... the proof of A ...
      we proved A
  ... the proof of T ...
  we proved T
</PRE>Otherwise said, <TT>generalize</TT> is not rendered in a forward-reasoning way,
while <TT>assert</TT> is.<BR>
<BR>
<!--TOC subsubsection What can I do if <SPAN STYLE="font-variant:small-caps">Coq</SPAN>can not infer some implicit argument ?-->

<H4 CLASS="subsubsection"><A NAME="htoc106">95</A>&nbsp;&nbsp;What can I do if <SPAN STYLE="font-variant:small-caps">Coq</SPAN>can not infer some implicit argument ?</H4><!--SEC END -->

You can state explicitely what this implicit argument is. See <A HREF="#implicit">96</A>.<BR>
<BR>
<!--TOC subsubsection How can I explicit some implicit argument ?-->

<H4 CLASS="subsubsection"><A NAME="htoc107">96</A>&nbsp;&nbsp;How can I explicit some implicit argument ?</H4><!--SEC END -->
<A NAME="implicit"></A>
Just use <TT>A:=term</TT> where <TT>A</TT> is the argument.<BR>
<BR>
For instance if you want to use the existence of &#8220;nil&#8221; on nat*nat lists:
<PRE CLASS="verbatim">
exists (nil (A:=(nat*nat))).
</PRE>
<!--TOC subsection Proof management-->

<H3 CLASS="subsection"><A NAME="htoc108">6.3</A>&nbsp;&nbsp;Proof management</H3><!--SEC END -->

<!--TOC subsubsection How can I change the order of the subgoals?-->

<H4 CLASS="subsubsection"><A NAME="htoc109">97</A>&nbsp;&nbsp;How can I change the order of the subgoals?</H4><!--SEC END -->

You can use the <TT>Focus</TT> command to concentrate on some goal. When the goal is proved you will see the remaining goals.<BR>
<BR>
<!--TOC subsubsection How can I change the order of the hypothesis?-->

<H4 CLASS="subsubsection"><A NAME="htoc110">98</A>&nbsp;&nbsp;How can I change the order of the hypothesis?</H4><!--SEC END -->

You can use the <TT>Move ... after</TT> command.<BR>
<BR>
<!--TOC subsubsection How can I change the name of an hypothesis?-->

<H4 CLASS="subsubsection"><A NAME="htoc111">99</A>&nbsp;&nbsp;How can I change the name of an hypothesis?</H4><!--SEC END -->

You can use the <TT>Rename ... into</TT> command.<BR>
<BR>
<!--TOC subsubsection How can I delete some hypothesis?-->

<H4 CLASS="subsubsection"><A NAME="htoc112">100</A>&nbsp;&nbsp;How can I delete some hypothesis?</H4><!--SEC END -->

You can use the <TT>Clear</TT> command.<BR>
<BR>
<!--TOC subsubsection How can use a proof which is not finished?-->

<H4 CLASS="subsubsection"><A NAME="htoc113">101</A>&nbsp;&nbsp;How can use a proof which is not finished?</H4><!--SEC END -->

You can use the <TT>Admitted</TT> command to state your current proof as an axiom.<BR>
<BR>
<!--TOC subsubsection How can I state a conjecture?-->

<H4 CLASS="subsubsection"><A NAME="htoc114">102</A>&nbsp;&nbsp;How can I state a conjecture?</H4><!--SEC END -->

You can use the <TT>Admitted</TT> command to state your current proof as an axiom.<BR>
<BR>
<!--TOC subsubsection What is the difference between a lemma, a fact and a theorem?-->

<H4 CLASS="subsubsection"><A NAME="htoc115">103</A>&nbsp;&nbsp;What is the difference between a lemma, a fact and a theorem?</H4><!--SEC END -->

From <SPAN STYLE="font-variant:small-caps">Coq</SPAN> point of view there are no difference. But some tools can
have a different behavior when you use a lemma rather than a
theorem. For instance <TT>coqdoc</TT> will not generate documentation for
the lemmas within your development.<BR>
<BR>
<!--TOC subsubsection How can I organize my proofs?-->

<H4 CLASS="subsubsection"><A NAME="htoc116">104</A>&nbsp;&nbsp;How can I organize my proofs?</H4><!--SEC END -->

You can organize your proofs using the section mechanism of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. Have
a look at the manual for further information.<BR>
<BR>
<!--TOC section Inductive and Co-inductive types-->

<H2 CLASS="section"><A NAME="htoc117">7</A>&nbsp;&nbsp;Inductive and Co-inductive types</H2><!--SEC END -->

<!--TOC subsection General-->

<H3 CLASS="subsection"><A NAME="htoc118">7.1</A>&nbsp;&nbsp;General</H3><!--SEC END -->

<!--TOC subsubsection How can I prove that two constructors are different?-->

<H4 CLASS="subsubsection"><A NAME="htoc119">105</A>&nbsp;&nbsp;How can I prove that two constructors are different?</H4><!--SEC END -->

You can use the <TT>discriminate</TT> tactic.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;toto&nbsp;:&nbsp;Set&nbsp;:=&nbsp;|&nbsp;C1&nbsp;:&nbsp;toto&nbsp;|&nbsp;C2&nbsp;:&nbsp;toto.</TT><BR>
<TT><I>toto&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>toto_rect&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>toto_ind&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>toto_rec&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Goal&nbsp;C1&nbsp;&lt;&gt;&nbsp;C2.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;C1&nbsp;&lt;&gt;&nbsp;C2</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;discriminate.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>&nbsp;discriminate.</I></TT><BR>
<TT><I>Unnamed_thm22&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection During an inductive proof, how to get rid of impossible cases of an inductive definition?-->

<H4 CLASS="subsubsection"><A NAME="htoc120">106</A>&nbsp;&nbsp;During an inductive proof, how to get rid of impossible cases of an inductive definition?</H4><!--SEC END -->

Use the <TT>inversion</TT> tactic.<BR>
<BR>
<!--TOC subsubsection How can I prove that 2 terms in an inductive set are equal? Or different?-->

<H4 CLASS="subsubsection"><A NAME="htoc121">107</A>&nbsp;&nbsp;How can I prove that 2 terms in an inductive set are equal? Or different?</H4><!--SEC END -->

Have a look at <TT>decide equality</TT> and <TT>discriminate</TT> in the <A HREF="http://coq.inria.fr/doc/main.html">Reference Manual</A>.<BR>
<BR>
<!--TOC subsubsection Why is the proof of <TT>0+n=n</TT> on natural numbers
trivial but the proof of <TT>n+0=n</TT> is not?-->

<H4 CLASS="subsubsection"><A NAME="htoc122">108</A>&nbsp;&nbsp;Why is the proof of <TT>0+n=n</TT> on natural numbers
trivial but the proof of <TT>n+0=n</TT> is not?</H4><!--SEC END -->

Since <TT>+</TT> (<TT>plus</TT>) on natural numbers is defined by analysis on its first argument<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;plus.</TT><BR>
<TT><I>plus&nbsp;=&nbsp;</I></TT><BR>
<TT><I>fix&nbsp;plus&nbsp;(n&nbsp;m&nbsp;:&nbsp;nat)&nbsp;{struct&nbsp;n}&nbsp;:&nbsp;nat&nbsp;:=</I></TT><BR>
<TT><I>&nbsp;&nbsp;match&nbsp;n&nbsp;with</I></TT><BR>
<TT><I>&nbsp;&nbsp;|&nbsp;0%nat&nbsp;=&gt;&nbsp;m</I></TT><BR>
<TT><I>&nbsp;&nbsp;|&nbsp;S&nbsp;p&nbsp;=&gt;&nbsp;S&nbsp;(p&nbsp;+&nbsp;m)</I></TT><BR>
<TT><I>&nbsp;&nbsp;end</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>Argument&nbsp;scopes&nbsp;are&nbsp;[nat_scope&nbsp;nat_scope]</I></TT><BR>
</DIV>
<BR>
<BR>
 The expression <TT>0+n</TT> evaluates to <TT>n</TT>. As <SPAN STYLE="font-variant:small-caps">Coq</SPAN> reasons
modulo evaluation of expressions, <TT>0+n</TT> and <TT>n</TT> are
considered equal and the theorem <TT>0+n=n</TT> is an instance of the
reflexivity of equality. On the other side, <TT>n+0</TT> does not
evaluate to <TT>n</TT> and a proof by induction on <TT>n</TT> is
necessary to trigger the evaluation of <TT>+</TT>.<BR>
<BR>
<!--TOC subsubsection Why is dependent elimination in Prop not
available by default?-->

<H4 CLASS="subsubsection"><A NAME="htoc123">109</A>&nbsp;&nbsp;Why is dependent elimination in Prop not
available by default?</H4><!--SEC END -->

This is just because most of the time it is not needed. To derive a
dependent elimination principle in <TT>Prop</TT>, use the command <TT>Scheme</TT> and
apply the elimination scheme using the <CODE>using</CODE> option of
<CODE>elim</CODE>, <CODE>destruct</CODE> or <CODE>induction</CODE>.<BR>
<BR>
<!--TOC subsubsection Argh! I cannot write expressions like &#8220;&nbsp;<TT>if n &lt;= p then p else n</TT>&nbsp;&#8221;, as in any programming language-->

<H4 CLASS="subsubsection"><A NAME="htoc124">110</A>&nbsp;&nbsp;Argh! I cannot write expressions like &#8220;&nbsp;<TT>if n &lt;= p then p else n</TT>&nbsp;&#8221;, as in any programming language</H4><!--SEC END -->

<A NAME="minmax"></A>
The short answer : You should use <TT>l</TT>e_lt_dec n p instead.<BR>
That's right, you can't.
If you type for instance the following &#8220;definition&#8221;:

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;max&nbsp;(n&nbsp;p&nbsp;:&nbsp;nat)&nbsp;:=&nbsp;if&nbsp;n&nbsp;&lt;=&nbsp;p&nbsp;then&nbsp;p&nbsp;else&nbsp;n.</TT><BR>
<TT><I>Toplevel&nbsp;input,&nbsp;characters&nbsp;33-39</I></TT><BR>
<TT><I>&gt;&nbsp;Definition&nbsp;max&nbsp;(n&nbsp;p&nbsp;:&nbsp;nat)&nbsp;:=&nbsp;if&nbsp;n&nbsp;&lt;=&nbsp;p&nbsp;then&nbsp;p&nbsp;else&nbsp;n.</I></TT><BR>
<TT><I>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^^^^^^</I></TT><BR>
<TT><I>Error:&nbsp;The&nbsp;term&nbsp;"n&nbsp;&lt;=&nbsp;p"&nbsp;has&nbsp;type&nbsp;"Prop"&nbsp;which&nbsp;is&nbsp;not&nbsp;a&nbsp;(co-)inductive&nbsp;type</I></TT><BR>
</DIV>
<BR>
<BR>
As <SPAN STYLE="font-variant:small-caps">Coq</SPAN>&nbsp; says, the term &#8220;&nbsp;<TT>n &lt;= p</TT>&nbsp;&#8221; is a proposition, i.e. a
statement that belongs to the mathematical world. There are many ways to
prove such a proposition, either by some computation, or using some already
proven theoremas. For instance, proving 3&minus;2 &#8804; 2<SUP>45503</SUP> is very easy,
using some theorems on arithmetical operations. If you compute both numbers
before comparing them, you risk to use a lot of time and space.<BR>
<BR>
On the contrary, a function for computing the greatest of two natural numbers
is an algorithm which, called on two natural numbers
<I>n</I> and <I>p</I>, determines wether <I>n</I>&#8804; <I>p</I> or <I>p</I> &lt; <I>n</I>.
Such a function is a <EM>decision procedure</EM> for the inequality of
 <TT>nat</TT>. The possibility of writing such a procedure comes 
directly from de decidability of the order &#8804; on natural numbers.<BR>
<BR>
When you write a piece of code like 
&#8220;&nbsp;<TT>if n &lt;= p then ... else ...</TT>&nbsp;&#8221;
in a
programming language like <EM>ML</EM> or <EM>Java</EM>, a call to such a 
decision procedure is generated. The decision procedure is in general
a primitive function, written in a low-level language, in the correctness
of which you have to trust.<BR>
<BR>
The standard Library of the system <EM>Coq</EM> contains a 
(constructive) proof of decidability of the order &#8804; on
<TT>nat</TT> : the function <TT>le_lt_dec</TT> of 
the module <TT>Compare_dec</TT> of library <TT>Arith</TT>.<BR>
<BR>
The following code shows how to define correctly <TT>min</TT> and
<TT>max</TT>, and prove some properties of these functions.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Compare_dec.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;max&nbsp;(n&nbsp;p&nbsp;:&nbsp;nat)&nbsp;:=&nbsp;if&nbsp;le_lt_dec&nbsp;n&nbsp;p&nbsp;then&nbsp;p&nbsp;else&nbsp;n.</TT><BR>
<TT><I>max&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;min&nbsp;(n&nbsp;p&nbsp;:&nbsp;nat)&nbsp;:=&nbsp;if&nbsp;le_lt_dec&nbsp;n&nbsp;p&nbsp;then&nbsp;n&nbsp;else&nbsp;p.</TT><BR>
<TT><I>min&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Eval&nbsp;compute&nbsp;in&nbsp;(min&nbsp;4&nbsp;7).</TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;4</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;min_plus_max&nbsp;:&nbsp;forall&nbsp;n&nbsp;p,&nbsp;min&nbsp;n&nbsp;p&nbsp;+&nbsp;max&nbsp;n&nbsp;p&nbsp;&nbsp;=&nbsp;n&nbsp;+&nbsp;p.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;p&nbsp;:&nbsp;nat,&nbsp;min&nbsp;n&nbsp;p&nbsp;+&nbsp;max&nbsp;n&nbsp;p&nbsp;=&nbsp;n&nbsp;+&nbsp;p</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;intros&nbsp;n&nbsp;p;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;unfold&nbsp;min,&nbsp;max;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;case&nbsp;(le_lt_dec&nbsp;n&nbsp;p);</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;simpl;&nbsp;auto&nbsp;with&nbsp;arith.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intros&nbsp;n&nbsp;p;&nbsp;unfold&nbsp;min,&nbsp;max&nbsp;in&nbsp;|-&nbsp;*;&nbsp;case&nbsp;(le_lt_dec&nbsp;n&nbsp;p);&nbsp;simpl&nbsp;in&nbsp;|-&nbsp;*;</I></TT><BR>
<TT><I>&nbsp;auto&nbsp;with&nbsp;arith.</I></TT><BR>
<TT><I>min_plus_max&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;max_equiv&nbsp;:&nbsp;forall&nbsp;n&nbsp;p,&nbsp;max&nbsp;n&nbsp;p&nbsp;=&nbsp;p&nbsp;&lt;-&gt;&nbsp;n&nbsp;&lt;=&nbsp;p.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;p&nbsp;:&nbsp;nat,&nbsp;max&nbsp;n&nbsp;p&nbsp;=&nbsp;p&nbsp;&lt;-&gt;&nbsp;n&nbsp;&lt;=&nbsp;p</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;unfold&nbsp;max;&nbsp;intros&nbsp;n&nbsp;p;&nbsp;case&nbsp;(le_lt_dec&nbsp;n&nbsp;p);simpl;&nbsp;auto.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;p&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;n&nbsp;&lt;=&nbsp;p&nbsp;-&gt;&nbsp;(p&nbsp;=&nbsp;p&nbsp;&lt;-&gt;&nbsp;n&nbsp;&lt;=&nbsp;p)</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;p&nbsp;&lt;&nbsp;n&nbsp;-&gt;&nbsp;(n&nbsp;=&nbsp;p&nbsp;&lt;-&gt;&nbsp;n&nbsp;&lt;=&nbsp;p)</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;intuition&nbsp;auto&nbsp;with&nbsp;arith.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;p&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;p&nbsp;&lt;&nbsp;n&nbsp;-&gt;&nbsp;(n&nbsp;=&nbsp;p&nbsp;&lt;-&gt;&nbsp;n&nbsp;&lt;=&nbsp;p)</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;split.&nbsp;</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;p&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;l&nbsp;:&nbsp;p&nbsp;&lt;&nbsp;n</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;p&nbsp;-&gt;&nbsp;n&nbsp;&lt;=&nbsp;p</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;n&nbsp;&lt;=&nbsp;p&nbsp;-&gt;&nbsp;n&nbsp;=&nbsp;p</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;intro&nbsp;e;&nbsp;rewrite&nbsp;e;&nbsp;auto&nbsp;with&nbsp;arith.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;p&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;l&nbsp;:&nbsp;p&nbsp;&lt;&nbsp;n</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;n&nbsp;&lt;=&nbsp;p&nbsp;-&gt;&nbsp;n&nbsp;=&nbsp;p</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;intro&nbsp;H;&nbsp;absurd&nbsp;(p&nbsp;&lt;&nbsp;p);&nbsp;eauto&nbsp;with&nbsp;arith.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>unfold&nbsp;max&nbsp;in&nbsp;|-&nbsp;*;&nbsp;intros&nbsp;n&nbsp;p;&nbsp;case&nbsp;(le_lt_dec&nbsp;n&nbsp;p);&nbsp;simpl&nbsp;in&nbsp;|-&nbsp;*;&nbsp;auto.</I></TT><BR>
<TT><I>&nbsp;&nbsp;intuitionauto&nbsp;with&nbsp;arith.</I></TT><BR>
<TT><I>split.</I></TT><BR>
<TT><I>&nbsp;intro&nbsp;e;&nbsp;rewrite&nbsp;e&nbsp;in&nbsp;|-&nbsp;*;&nbsp;auto&nbsp;with&nbsp;arith.</I></TT><BR>
<TT><I>intro&nbsp;H;&nbsp;&nbsp;absurd&nbsp;(p&nbsp;&lt;&nbsp;p);&nbsp;&nbsp;eauto&nbsp;with&nbsp;arith.</I></TT><BR>
<TT><I>max_equiv&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection I wrote my own decision procedure for &#8804;, which
is much faster than yours, but proving such theorems as
 <TT>max_equiv</TT> seems to be quite difficult-->

<H4 CLASS="subsubsection"><A NAME="htoc125">111</A>&nbsp;&nbsp;I wrote my own decision procedure for &#8804;, which
is much faster than yours, but proving such theorems as
 <TT>max_equiv</TT> seems to be quite difficult</H4><!--SEC END -->

Your code is probably the following one:<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Fixpoint&nbsp;my_le_lt_dec&nbsp;(n&nbsp;p&nbsp;:nat)&nbsp;{struct&nbsp;n}:&nbsp;bool&nbsp;&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;match&nbsp;n,&nbsp;p&nbsp;with&nbsp;0,&nbsp;_&nbsp;=&gt;&nbsp;true</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;n',&nbsp;S&nbsp;p'&nbsp;=&gt;&nbsp;my_le_lt_dec&nbsp;n'&nbsp;p'</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;_&nbsp;&nbsp;&nbsp;,&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;false</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;end.</TT><BR>
<TT><I>my_le_lt_dec&nbsp;is&nbsp;recursively&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;my_max&nbsp;(n&nbsp;p:nat)&nbsp;:=&nbsp;if&nbsp;my_le_lt_dec&nbsp;n&nbsp;p&nbsp;then&nbsp;p&nbsp;else&nbsp;n.</TT><BR>
<TT><I>my_max&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;my_min&nbsp;(n&nbsp;p:nat)&nbsp;:=&nbsp;if&nbsp;my_le_lt_dec&nbsp;n&nbsp;p&nbsp;then&nbsp;n&nbsp;else&nbsp;p.</TT><BR>
<TT><I>my_min&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
For instance, the computation of <TT>my_max 567 321</TT> is almost
immediate, whereas one can't wait for the result of 
<TT>max 56 32</TT>, using <EM>Coq's</EM> <TT>le_lt_dec</TT>.<BR>
<BR>
This is normal. Your definition is a simple recursive function which
returns a boolean value. Coq's <TT>le_lt_dec</TT> is a <EM>certified
function</EM>, i.e. a complex object, able not only to tell wether <I>n</I>&#8804; <I>p</I>
or <I>p</I>&lt;<I>n</I>, but also of building a complete proof of the correct inequality.
What make <TT>le_lt_dec</TT> inefficient for computing <TT>min</TT>
and <TT>max</TT> is the building of a huge proof term.<BR>
<BR>
Nevertheless, <TT>le_lt_dec</TT> is very useful. Its type 
is a strong specification, using the
<TT>sumbool</TT> type (look at the reference manual or chapter 9 of
[<A HREF="#coqart"><CITE>1</CITE></A>]). Eliminations of the form
&#8220;&nbsp;<TT>case (le_lt_dec n p)</TT>&nbsp;&#8221; provide proofs of
either <I>n</I> &#8804; <I>p</I> or <I>p</I> &lt; <I>n</I>, allowing to prove easily theorems as in
question&nbsp;<A HREF="#minmax">110</A>. Unfortunately, this not the case of your
<TT>my_le_lt_dec</TT>, which returns a quite non-informative boolean
value.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Check&nbsp;le_lt_dec.</TT><BR>
<TT><I>le_lt_dec</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;{n&nbsp;&lt;=&nbsp;m}&nbsp;+&nbsp;{m&nbsp;&lt;&nbsp;n}</I></TT><BR>
</DIV>
<BR>
<BR>
You should keep in mind that <TT>le_lt_dec</TT> is useful to build
certified programs which need to compare natural numbers, and is not
designed to compare quickly two numbers.<BR>
<BR>
Nevertheless, the <EM>extraction</EM> of <TT>le_lt_dec</TT> towards 
<EM>Ocaml</EM> or <EM>Haskell</EM>, is a reasonable program for comparing two
natural numbers in Peano form in linear time.<BR>
<BR>
It is also possible to keep your boolean function as a decision procedure,
but you have to establish yourself the relationship between <TT>my_le_lt_dec</TT> and the propositions <I>n</I>&#8804; <I>p</I> and <I>p</I>&lt;<I>n</I>:<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;my_le_lt_dec_true&nbsp;:&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;p,&nbsp;my_le_lt_dec&nbsp;n&nbsp;p&nbsp;=&nbsp;true&nbsp;&lt;-&gt;&nbsp;n&nbsp;&lt;=&nbsp;p.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;&nbsp;my_le_lt_dec_false&nbsp;:&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;p,&nbsp;my_le_lt_dec&nbsp;n&nbsp;p&nbsp;=&nbsp;false&nbsp;&lt;-&gt;&nbsp;p&nbsp;&lt;&nbsp;n.</TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsection Recursion-->

<H3 CLASS="subsection"><A NAME="htoc126">7.2</A>&nbsp;&nbsp;Recursion</H3><!--SEC END -->

<!--TOC subsubsection Why can't I define a non terminating program?-->

<H4 CLASS="subsubsection"><A NAME="htoc127">112</A>&nbsp;&nbsp;Why can't I define a non terminating program?</H4><!--SEC END -->

Because otherwise the decidability of the type-checking
algorithm (which involves evaluation of programs) is not ensured. On
another side, if non terminating proofs were allowed, we could get a
proof of <TT>False</TT>:<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;(*&nbsp;This&nbsp;is&nbsp;fortunately&nbsp;not&nbsp;allowed!&nbsp;*)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Fixpoint&nbsp;InfiniteProof&nbsp;(n:nat)&nbsp;:&nbsp;False&nbsp;:=&nbsp;InfiniteProof&nbsp;n.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;Paradox&nbsp;:&nbsp;False.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof&nbsp;(InfiniteProof&nbsp;O).</TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection Why only structurally well-founded loops are allowed?-->

<H4 CLASS="subsubsection"><A NAME="htoc128">113</A>&nbsp;&nbsp;Why only structurally well-founded loops are allowed?</H4><!--SEC END -->

The structural order on inductive types is a simple and
powerful notion of termination. The consistency of the Calculus of
Inductive Constructions relies on it and another consistency proof
would have to be made for stronger termination arguments (such
as the termination of the evaluation of CIC programs themselves!).<BR>
<BR>
In spite of this, all non-pathological termination orders can be mapped
to a structural order. Tools to do this are provided in the file 
<A HREF="http://coq.inria.fr/library/Coq.Init.Wf.html
"><TT>Wf.v</TT></A> of the standard library of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.<BR>
<BR>
<!--TOC subsubsection How to define loops based on non structurally smaller
recursive calls?-->

<H4 CLASS="subsubsection"><A NAME="htoc129">114</A>&nbsp;&nbsp;How to define loops based on non structurally smaller
recursive calls?</H4><!--SEC END -->

The procedure is as follows (we consider the definition of <TT>mergesort</TT> as an example).
<UL CLASS="itemize"><LI CLASS="li-itemize">Define the termination order, say <TT>R</TT> on the type <TT>A</TT> of
the arguments of the loop.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;R&nbsp;(a&nbsp;b:list&nbsp;nat)&nbsp;:=&nbsp;length&nbsp;a&nbsp;&lt;&nbsp;length&nbsp;b.</TT><BR>
</DIV>
<BR>
<BR>
<LI CLASS="li-itemize">Prove that this order is well-founded (in fact that all elements in <TT>A</TT> are accessible along <TT>R</TT>).<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;Rwf&nbsp;:&nbsp;well_founded&nbsp;R.</TT><BR>
</DIV>
<BR>
<BR>
<LI CLASS="li-itemize">Define the step function (which needs proofs that recursive
calls are on smaller arguments).<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;split&nbsp;(l&nbsp;:&nbsp;list&nbsp;nat)&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;{l1:&nbsp;list&nbsp;nat&nbsp;|&nbsp;R&nbsp;l1&nbsp;l}&nbsp;*&nbsp;{l2&nbsp;:&nbsp;list&nbsp;nat&nbsp;|&nbsp;R&nbsp;l2&nbsp;l}</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;:=&nbsp;(*&nbsp;...&nbsp;*)&nbsp;.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;concat&nbsp;(l1&nbsp;l2&nbsp;:&nbsp;list&nbsp;nat)&nbsp;:&nbsp;list&nbsp;nat&nbsp;:=&nbsp;(*&nbsp;...&nbsp;*)&nbsp;.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;merge_step&nbsp;(l&nbsp;:&nbsp;list&nbsp;nat)&nbsp;(f:&nbsp;forall&nbsp;l':list&nbsp;nat,&nbsp;R&nbsp;l'&nbsp;l&nbsp;-&gt;&nbsp;list&nbsp;nat)&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;let&nbsp;(lH1,lH2)&nbsp;:=&nbsp;(split&nbsp;l)&nbsp;in</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;let&nbsp;(l1,H1)&nbsp;:=&nbsp;lH1&nbsp;in</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;let&nbsp;(l2,H2)&nbsp;:=&nbsp;lH2&nbsp;in</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;concat&nbsp;(f&nbsp;l1&nbsp;H1)&nbsp;(f&nbsp;l2&nbsp;H2).</TT><BR>
</DIV>
<BR>
<BR>
<LI CLASS="li-itemize">Define the recursive function by fixpoint on the step function.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;merge&nbsp;:=&nbsp;Fix&nbsp;Rwf&nbsp;(fun&nbsp;_&nbsp;=&gt;&nbsp;list&nbsp;nat)&nbsp;merge_step.</TT><BR>
</DIV>
</UL>
<!--TOC subsubsection What is behind the accessibility and well-foundedness proofs?-->

<H4 CLASS="subsubsection"><A NAME="htoc130">115</A>&nbsp;&nbsp;What is behind the accessibility and well-foundedness proofs?</H4><!--SEC END -->

Well-foundedness of some relation <TT>R</TT> on some type <TT>A</TT>
is defined as the accessibility of all elements of <TT>A</TT> along <TT>R</TT>.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;well_founded.</TT><BR>
<TT><I>well_founded&nbsp;=&nbsp;</I></TT><BR>
<TT><I>fun&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(R&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;Prop)&nbsp;=&gt;&nbsp;forall&nbsp;a&nbsp;:&nbsp;A,&nbsp;Acc&nbsp;R&nbsp;a</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;(A&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;Prop)&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>Argument&nbsp;A&nbsp;is&nbsp;implicit</I></TT><BR>
<TT><I>Argument&nbsp;scopes&nbsp;are&nbsp;[type_scope&nbsp;_]</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;Acc.</TT><BR>
<TT><I>Inductive&nbsp;Acc&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(R&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;Prop)&nbsp;(x&nbsp;:&nbsp;A)&nbsp;:&nbsp;Prop&nbsp;:=</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;Acc_intro&nbsp;:&nbsp;(forall&nbsp;y&nbsp;:&nbsp;A,&nbsp;R&nbsp;y&nbsp;x&nbsp;-&gt;&nbsp;Acc&nbsp;R&nbsp;y)&nbsp;-&gt;&nbsp;Acc&nbsp;R&nbsp;x</I></TT><BR>
<TT><I>For&nbsp;Acc:&nbsp;Argument&nbsp;A&nbsp;is&nbsp;implicit</I></TT><BR>
<TT><I>For&nbsp;Acc_intro:&nbsp;Arguments&nbsp;A,&nbsp;R&nbsp;are&nbsp;implicit</I></TT><BR>
<TT><I>For&nbsp;Acc:&nbsp;Argument&nbsp;scopes&nbsp;are&nbsp;[type_scope&nbsp;_&nbsp;_]</I></TT><BR>
<TT><I>For&nbsp;Acc_intro:&nbsp;Argument&nbsp;scopes&nbsp;are&nbsp;[type_scope&nbsp;_&nbsp;_&nbsp;_]</I></TT><BR>
</DIV>
<BR>
<BR>
The structure of the accessibility predicate is a well-founded tree
branching at each node <TT>x</TT> in <TT>A</TT> along all the nodes <TT>x'</TT>
less than <TT>x</TT> along <TT>R</TT>. Any sequence of elements of <TT>A</TT>
decreasing along the order <TT>R</TT> are branches in the accessibility
tree. Hence any decreasing along <TT>R</TT> is mapped into a structural
decreasing in the accessibility tree of <TT>R</TT>. This is emphasised in
the definition of <TT>fix</TT> which recurs not on its argument <TT>x:A</TT>
but on the accessibility of this argument along <TT>R</TT>.<BR>
<BR>
See file <A HREF="http://coq.inria.fr/library/Coq.Init.Wf.html
"><TT>Wf.v</TT></A>.<BR>
<BR>
<!--TOC subsubsection How to perform simultaneous double induction?-->

<H4 CLASS="subsubsection"><A NAME="htoc131">116</A>&nbsp;&nbsp;How to perform simultaneous double induction?</H4><!--SEC END -->

In general a (simultaneous) double induction is simply solved by an
induction on the first hypothesis followed by an inversion over the
second hypothesis. Here is an example<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;even&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;even_O&nbsp;:&nbsp;even&nbsp;0</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;even_S&nbsp;:&nbsp;forall&nbsp;n:nat,&nbsp;even&nbsp;n&nbsp;-&gt;&nbsp;even&nbsp;(S&nbsp;(S&nbsp;n)).</TT><BR>
<TT><I>even&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>even_ind&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;odd&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;odd_SO&nbsp;:&nbsp;odd&nbsp;1</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;odd_S&nbsp;:&nbsp;forall&nbsp;n:nat,&nbsp;odd&nbsp;n&nbsp;-&gt;&nbsp;odd&nbsp;(S&nbsp;(S&nbsp;n)).</TT><BR>
<TT><I>odd&nbsp;is&nbsp;defined</I></TT><BR>
<TT><I>odd_ind&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;not_even_and_odd&nbsp;:&nbsp;forall&nbsp;n:nat,&nbsp;even&nbsp;n&nbsp;-&gt;&nbsp;odd&nbsp;n&nbsp;-&gt;&nbsp;False.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;even&nbsp;n&nbsp;-&gt;&nbsp;odd&nbsp;n&nbsp;-&gt;&nbsp;False</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;induction&nbsp;1.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;odd&nbsp;0&nbsp;-&gt;&nbsp;False</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;odd&nbsp;(S&nbsp;(S&nbsp;n))&nbsp;-&gt;&nbsp;False</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;inversion&nbsp;1.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;even&nbsp;n</I></TT><BR>
<TT><I>&nbsp;&nbsp;IHeven&nbsp;:&nbsp;odd&nbsp;n&nbsp;-&gt;&nbsp;False</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;odd&nbsp;(S&nbsp;(S&nbsp;n))&nbsp;-&gt;&nbsp;False</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;inversion&nbsp;1.&nbsp;apply&nbsp;IHeven;&nbsp;trivial.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H&nbsp;:&nbsp;even&nbsp;n</I></TT><BR>
<TT><I>&nbsp;&nbsp;IHeven&nbsp;:&nbsp;odd&nbsp;n&nbsp;-&gt;&nbsp;False</I></TT><BR>
<TT><I>&nbsp;&nbsp;H0&nbsp;:&nbsp;odd&nbsp;(S&nbsp;(S&nbsp;n))</I></TT><BR>
<TT><I>&nbsp;&nbsp;n0&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;H2&nbsp;:&nbsp;odd&nbsp;n</I></TT><BR>
<TT><I>&nbsp;&nbsp;H1&nbsp;:&nbsp;n0&nbsp;=&nbsp;n</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;False</I></TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
</DIV>
<BR>
<BR>
In case the type of the second induction hypothesis is not
dependent, <TT>inversion</TT> can just be replaced by <TT>destruct</TT>.<BR>
<BR>
<!--TOC subsubsection How to define a function by simultaneous double recursion?-->

<H4 CLASS="subsubsection"><A NAME="htoc132">117</A>&nbsp;&nbsp;How to define a function by simultaneous double recursion?</H4><!--SEC END -->

The same trick applies, you can even use the pattern-matching
compilation algorithm to do the work for you. Here is an example:<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Fixpoint&nbsp;minus&nbsp;(n&nbsp;m:nat)&nbsp;{struct&nbsp;n}&nbsp;:&nbsp;nat&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;match&nbsp;n,&nbsp;m&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;O,&nbsp;_&nbsp;=&gt;&nbsp;0</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;k,&nbsp;O&nbsp;=&gt;&nbsp;S&nbsp;k</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;k,&nbsp;S&nbsp;l&nbsp;=&gt;&nbsp;minus&nbsp;k&nbsp;l</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<TT><I>minus&nbsp;is&nbsp;recursively&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Print&nbsp;&nbsp;minus.</TT><BR>
<TT><I>minus&nbsp;=&nbsp;</I></TT><BR>
<TT><I>fix&nbsp;minus&nbsp;(n&nbsp;m&nbsp;:&nbsp;nat)&nbsp;{struct&nbsp;n}&nbsp;:&nbsp;nat&nbsp;:=</I></TT><BR>
<TT><I>&nbsp;&nbsp;match&nbsp;n&nbsp;with</I></TT><BR>
<TT><I>&nbsp;&nbsp;|&nbsp;0&nbsp;=&gt;&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;|&nbsp;S&nbsp;k&nbsp;=&gt;&nbsp;match&nbsp;m&nbsp;with</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;0&nbsp;=&gt;&nbsp;S&nbsp;k</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;l&nbsp;=&gt;&nbsp;k&nbsp;-&nbsp;l</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</I></TT><BR>
<TT><I>&nbsp;&nbsp;end</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat</I></TT><BR>
<TT><I>Argument&nbsp;scopes&nbsp;are&nbsp;[nat_scope&nbsp;nat_scope]</I></TT><BR>
</DIV>
<BR>
<BR>
In case of dependencies in the type of the induction objects
<I>t</I><SUB>1</SUB> and <I>t</I><SUB>2</SUB>, an extra argument stating <I>t</I><SUB>1</SUB>=<I>t</I><SUB>2</SUB> must be given to
the fixpoint definition<BR>
<BR>
<!--TOC subsubsection How to perform nested and double induction?-->

<H4 CLASS="subsubsection"><A NAME="htoc133">118</A>&nbsp;&nbsp;How to perform nested and double induction?</H4><!--SEC END -->

To reason by nested (i.e. lexicographic) induction, just reason by
induction on the successive components.<BR>
<BR>
<BR>
<BR>
<BR>
Double induction (or induction on pairs) is a restriction of the
lexicographic induction. Here is an example of double induction.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;nat_double_ind&nbsp;:&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop,&nbsp;P&nbsp;0&nbsp;0&nbsp;-&gt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;(forall&nbsp;m&nbsp;n,&nbsp;P&nbsp;m&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;m&nbsp;(S&nbsp;n))&nbsp;-&gt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;(forall&nbsp;m&nbsp;n,&nbsp;P&nbsp;m&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;m)&nbsp;n)&nbsp;-&gt;&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;m&nbsp;n,&nbsp;P&nbsp;m&nbsp;n.</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop,</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;P&nbsp;0&nbsp;0&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;(forall&nbsp;m&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;m&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;m&nbsp;(S&nbsp;n))&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;(forall&nbsp;m&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;m&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;m)&nbsp;n)&nbsp;-&gt;&nbsp;forall&nbsp;m&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;m&nbsp;n</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros&nbsp;P&nbsp;H00&nbsp;HmS&nbsp;HSn;&nbsp;induction&nbsp;m.</TT><BR>
<TT><I>2&nbsp;subgoals</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H00&nbsp;:&nbsp;P&nbsp;0&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;HmS&nbsp;:&nbsp;forall&nbsp;m&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;m&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;m&nbsp;(S&nbsp;n)</I></TT><BR>
<TT><I>&nbsp;&nbsp;HSn&nbsp;:&nbsp;forall&nbsp;m&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;m&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;m)&nbsp;n</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;0&nbsp;n</I></TT><BR>
<TT><I>subgoal&nbsp;2&nbsp;is:</I></TT><BR>
<TT><I>&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;(S&nbsp;m)&nbsp;n</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;(*&nbsp;case&nbsp;0&nbsp;*)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;induction&nbsp;n;&nbsp;[assumption&nbsp;|&nbsp;apply&nbsp;HmS;&nbsp;apply&nbsp;IHn].</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop</I></TT><BR>
<TT><I>&nbsp;&nbsp;H00&nbsp;:&nbsp;P&nbsp;0&nbsp;0</I></TT><BR>
<TT><I>&nbsp;&nbsp;HmS&nbsp;:&nbsp;forall&nbsp;m&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;m&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;m&nbsp;(S&nbsp;n)</I></TT><BR>
<TT><I>&nbsp;&nbsp;HSn&nbsp;:&nbsp;forall&nbsp;m&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;m&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;m)&nbsp;n</I></TT><BR>
<TT><I>&nbsp;&nbsp;m&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;IHm&nbsp;:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;m&nbsp;n</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;(S&nbsp;m)&nbsp;n</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;(*&nbsp;case&nbsp;Sm&nbsp;*)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;intro&nbsp;n;&nbsp;apply&nbsp;HSn;&nbsp;apply&nbsp;IHm.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection How to define a function by nested recursion?-->

<H4 CLASS="subsubsection"><A NAME="htoc134">119</A>&nbsp;&nbsp;How to define a function by nested recursion?</H4><!--SEC END -->

The same trick applies. Here is the example of Ackermann
function.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Fixpoint&nbsp;ack&nbsp;(n:nat)&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;O&nbsp;=&gt;&nbsp;S</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;n'&nbsp;=&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fix&nbsp;ack'&nbsp;(m:nat)&nbsp;:&nbsp;nat&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;m&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;O&nbsp;=&gt;&nbsp;ack&nbsp;n'&nbsp;1</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;m'&nbsp;=&gt;&nbsp;ack&nbsp;n'&nbsp;(ack'&nbsp;m')</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end)</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;end.</TT><BR>
<TT><I>ack&nbsp;is&nbsp;recursively&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsection Co-inductive types-->

<H3 CLASS="subsection"><A NAME="htoc135">7.3</A>&nbsp;&nbsp;Co-inductive types</H3><!--SEC END -->

<!--TOC subsubsection I have a cofixpoint <I>t</I>:=<I>F</I>(<I>t</I>) and I want to prove <I>t</I>=<I>F</I>(<I>t</I>). How to do it?-->

<H4 CLASS="subsubsection"><A NAME="htoc136">120</A>&nbsp;&nbsp;I have a cofixpoint <I>t</I>:=<I>F</I>(<I>t</I>) and I want to prove <I>t</I>=<I>F</I>(<I>t</I>). How to do it?</H4><!--SEC END -->

Just case-expand <I>F</I>(<TT><I>t</I></TT>) then complete by a trivial case analysis.
Here is what it gives on e.g. the type of streams on naturals<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;CoInductive&nbsp;Stream&nbsp;(A:Set)&nbsp;:&nbsp;Set&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;Cons&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Stream&nbsp;A&nbsp;-&gt;&nbsp;Stream&nbsp;A.</TT><BR>
<TT><I>Stream&nbsp;is&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;CoFixpoint&nbsp;nats&nbsp;(n:nat)&nbsp;:&nbsp;Stream&nbsp;nat&nbsp;:=&nbsp;Cons&nbsp;n&nbsp;(nats&nbsp;(S&nbsp;n)).</TT><BR>
<TT><I>nats&nbsp;is&nbsp;corecursively&nbsp;defined</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;Stream_unfold&nbsp;:&nbsp;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n:nat,&nbsp;nats&nbsp;n&nbsp;=&nbsp;Cons&nbsp;n&nbsp;(nats&nbsp;(S&nbsp;n)).</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;nats&nbsp;n&nbsp;=&nbsp;Cons&nbsp;n&nbsp;(nats&nbsp;(S&nbsp;n))</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;intro;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;change&nbsp;(nats&nbsp;n&nbsp;=&nbsp;match&nbsp;nats&nbsp;n&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Cons&nbsp;x&nbsp;s&nbsp;=&gt;&nbsp;Cons&nbsp;x&nbsp;s</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end).</TT><BR>
<TT><I>1&nbsp;subgoal</I></TT><BR>
<TT><I>&nbsp;&nbsp;</I></TT><BR>
<TT><I>&nbsp;&nbsp;n&nbsp;:&nbsp;nat</I></TT><BR>
<TT><I>&nbsp;&nbsp;============================</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;nats&nbsp;n&nbsp;=&nbsp;match&nbsp;nats&nbsp;n&nbsp;with</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Cons&nbsp;x&nbsp;s&nbsp;=&gt;&nbsp;Cons&nbsp;x&nbsp;s</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;case&nbsp;(nats&nbsp;n);&nbsp;reflexivity.</TT><BR>
<TT><I>Proof&nbsp;completed.</I></TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
<TT><I>intro;&nbsp;change&nbsp;(nats&nbsp;n&nbsp;=&nbsp;match&nbsp;nats&nbsp;n&nbsp;with</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Cons&nbsp;x&nbsp;s&nbsp;=&gt;&nbsp;Cons&nbsp;x&nbsp;s</I></TT><BR>
<TT><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end)&nbsp;in&nbsp;|-&nbsp;*.</I></TT><BR>
<TT><I>case&nbsp;(nats&nbsp;n);&nbsp;reflexivity.</I></TT><BR>
<TT><I>Stream_unfold&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC section Syntax and notations-->

<H2 CLASS="section"><A NAME="htoc137">8</A>&nbsp;&nbsp;Syntax and notations</H2><!--SEC END -->

<!--TOC subsubsection I do not want to type &#8220;forall&#8221; because it is too long, what can I do?-->

<H4 CLASS="subsubsection"><A NAME="htoc138">121</A>&nbsp;&nbsp;I do not want to type &#8220;forall&#8221; because it is too long, what can I do?</H4><!--SEC END -->

You can define your own notation for forall:
<PRE CLASS="verbatim">
Notation "fa x : t, P" := (forall x:t, P) (at level 200, x ident).
</PRE>or if your are using <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN> you can define a pretty symbol for for all and an input method (see <A HREF="#forallcoqide">152</A>).<BR>
<BR>
<!--TOC subsubsection How can I define a notation for square?-->

<H4 CLASS="subsubsection"><A NAME="htoc139">122</A>&nbsp;&nbsp;How can I define a notation for square?</H4><!--SEC END -->

You can use for instance:
<PRE CLASS="verbatim">
Notation "x ^2" := (Rmult x x) (at level 20).
</PRE>Note that you can not use:
<TT>N</TT>otation "x <SUP>²</SUP>" := (Rmult x x) (at level 20).

because &#8220;<SUP>2</SUP>&#8221; is an iso-latin character. If you really want this kind of notation you should use UTF-8.<BR>
<BR>
<!--TOC subsubsection Why &#8220;no associativity&#8221; and &#8220;left associativity&#8221; at the same level does not work?-->

<H4 CLASS="subsubsection"><A NAME="htoc140">123</A>&nbsp;&nbsp;Why &#8220;no associativity&#8221; and &#8220;left associativity&#8221; at the same level does not work?</H4><!--SEC END -->

Because we relie on camlp4 for syntactical analysis and camlp4 does not really implement no associativity. By default, non associative operators are defined as right associative.<BR>
<BR>
<!--TOC subsubsection How can I know the associativity associated with a level?-->

<H4 CLASS="subsubsection"><A NAME="htoc141">124</A>&nbsp;&nbsp;How can I know the associativity associated with a level?</H4><!--SEC END -->

You can do &#8220;Print Grammar constr&#8221;, and decode the output from camlp4, good luck !<BR>
<BR>
<!--TOC section Modules-->

<H2 CLASS="section"><A NAME="htoc142">9</A>&nbsp;&nbsp;Modules</H2><!--SEC END -->

<!--TOC section <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>-->

<H2 CLASS="section"><A NAME="htoc143">10</A>&nbsp;&nbsp;<SPAN STYLE="font-variant:small-caps">Ltac</SPAN></H2><!--SEC END -->

<!--TOC subsubsection What is <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc144">125</A>&nbsp;&nbsp;What is <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?</H4><!--SEC END -->

<SPAN STYLE="font-variant:small-caps">Ltac</SPAN> is the tactic language for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. It provides the user with a
high-level &#8220;toolbox&#8221; for tactic creation.<BR>
<BR>
<!--TOC subsubsection Why do I always get the same error message?-->

<H4 CLASS="subsubsection"><A NAME="htoc145">126</A>&nbsp;&nbsp;Why do I always get the same error message?</H4><!--SEC END -->

<!--TOC subsubsection Is there any printing command in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc146">127</A>&nbsp;&nbsp;Is there any printing command in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?</H4><!--SEC END -->

You can use the <TT>idtac</TT> tactic with a string argument. This string
will be printed out. The same applies to the <TT>fail</TT> tactic<BR>
<BR>
<!--TOC subsubsection What is the syntax for let in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc147">128</A>&nbsp;&nbsp;What is the syntax for let in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?</H4><!--SEC END -->

If <I>x</I><SUB><I>i</I></SUB> are identifiers and <I>e</I><SUB><I>i</I></SUB> and <I>expr</I> are tactic expressions, then let reads:
<DIV CLASS="center">
<TT>let <I>x</I></TT><SUB><TT>1</TT></SUB><TT>:=<I>e</I></TT><SUB><TT>1</TT></SUB><TT> with <I>x</I></TT><SUB><TT>2</TT></SUB><TT>:=<I>e</I></TT><SUB><TT>2</TT></SUB><TT>...with <I>x</I></TT><SUB><TT><I>n</I></TT></SUB><TT>:=<I>e</I></TT><SUB><TT><I>n</I></TT></SUB><TT> in
<I>expr</I></TT>.
</DIV>
Beware that if <I>expr</I> is complex (i.e. features at least a sequence) parenthesis
should be added around it. For example: 

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Ltac&nbsp;twoIntro&nbsp;:=&nbsp;let&nbsp;x:=intro&nbsp;in&nbsp;(x;x).</TT><BR>
<TT><I>twoIntro&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection What is the syntax for pattern matching in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc148">129</A>&nbsp;&nbsp;What is the syntax for pattern matching in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?</H4><!--SEC END -->

Pattern matching on a term <I>expr</I> (non-linear first order unification)
with patterns <I>p</I><SUB><I>i</I></SUB> and tactic expressions <I>e</I><SUB><I>i</I></SUB> reads:
<DIV CLASS="center">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<TT>match <I>expr</I> with
&nbsp;&nbsp;<I>p</I></TT><SUB><TT>1</TT></SUB><TT> =&gt; <I>e</I></TT><SUB><TT>1</TT></SUB><TT>
&nbsp;|<I>p</I></TT><SUB><TT>2</TT></SUB><TT> =&gt; <I>e</I></TT><SUB><TT>2</TT></SUB><TT>
&nbsp;...&nbsp;|<I>p</I></TT><SUB><TT><I>n</I></TT></SUB><TT> =&gt; <I>e</I></TT><SUB><TT><I>n</I></TT></SUB><TT>
&nbsp;| _ =&gt; <I>e</I></TT><SUB><TT><I>n</I>+1</TT></SUB><TT>
end.
</TT>
</DIV>
Underscore matches all terms.<BR>
<BR>
<!--TOC subsubsection What is the semantics for &#8220;match goal&#8221;?-->

<H4 CLASS="subsubsection"><A NAME="htoc149">130</A>&nbsp;&nbsp;What is the semantics for &#8220;match goal&#8221;?</H4><!--SEC END -->

The semantics of <TT>match goal</TT> depends on whether it returns
tactics or not. The <TT>match goal</TT> expression matches the current
goal against a series of patterns: <I>hyp</I><SUB>1</SUB> &hellip; <I>hyp</I><SUB><I>n</I></SUB> |-
<I>ccl</I>. It uses a first-order unification algorithm and in case of
success, if the right-hand-side is an expression, it tries to type it
while if the right-hand-side is a tactic, it tries to apply it. If the
typing or the tactic application fails, the <TT>match goal</TT> tries all
the possible combinations of <I>hyp</I><SUB><I>i</I></SUB> before dropping the branch and
moving to the next one. Underscore matches all terms.<BR>
<BR>
<!--TOC subsubsection Why can't I use a &#8220;match goal&#8221; returning a tactic in a non
tail-recursive position?-->

<H4 CLASS="subsubsection"><A NAME="htoc150">131</A>&nbsp;&nbsp;Why can't I use a &#8220;match goal&#8221; returning a tactic in a non
tail-recursive position?</H4><!--SEC END -->

This is precisely because the semantics of <TT>match goal</TT> is to
apply the tactic on the right as soon as a pattern unifies what is
meaningful only in tail-recursive uses.<BR>
<BR>
The semantics in non tail-recursive call could have been the one used
for terms (i.e. fail if the tactic expression is not typable, but
don't try to apply it). For uniformity of semantics though, this has
been rejected.<BR>
<BR>
<!--TOC subsubsection How can I generate a new name?-->

<H4 CLASS="subsubsection"><A NAME="htoc151">132</A>&nbsp;&nbsp;How can I generate a new name?</H4><!--SEC END -->

You can use the following syntax:
<TT>let id:=fresh in ...</TT><BR>
For example:

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Ltac&nbsp;introIdGen&nbsp;:=&nbsp;let&nbsp;id:=fresh&nbsp;in&nbsp;intro&nbsp;id.</TT><BR>
<TT><I>introIdGen&nbsp;is&nbsp;defined</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection How can I define static and dynamic code?-->

<H4 CLASS="subsubsection"><A NAME="htoc152">133</A>&nbsp;&nbsp;How can I define static and dynamic code?</H4><!--SEC END -->

<!--TOC section Tactics written in Ocaml-->

<H2 CLASS="section"><A NAME="htoc153">11</A>&nbsp;&nbsp;Tactics written in Ocaml</H2><!--SEC END -->

<!--TOC subsubsection Can you show me an example of a tactic written in OCaml?-->

<H4 CLASS="subsubsection"><A NAME="htoc154">134</A>&nbsp;&nbsp;Can you show me an example of a tactic written in OCaml?</H4><!--SEC END -->

You have some examples of tactics written in Ocaml in the &#8220;contrib&#8221; directory of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> sources. <BR>
<BR>
<!--TOC section Case studies-->

<H2 CLASS="section"><A NAME="htoc155">12</A>&nbsp;&nbsp;Case studies</H2><!--SEC END -->

<!--TOC subsubsection How can I define vectors or lists of size n?-->

<H4 CLASS="subsubsection"><A NAME="htoc156">135</A>&nbsp;&nbsp;How can I define vectors or lists of size n?</H4><!--SEC END -->

<!--TOC subsubsection How to prove that 2 sets are different?-->

<H4 CLASS="subsubsection"><A NAME="htoc157">136</A>&nbsp;&nbsp;How to prove that 2 sets are different?</H4><!--SEC END -->

You need to find a property true on one set and false on the
other one. As an example we show how to prove that <TT>bool</TT> and <TT>nat</TT> are discriminable. As discrimination property we take the
property to have no more than 2 elements.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;nat_bool_discr&nbsp;:&nbsp;bool&nbsp;&lt;&gt;&nbsp;nat.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;pose&nbsp;(discr&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;X:Set&nbsp;=&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~&nbsp;(forall&nbsp;a&nbsp;b:X,&nbsp;~&nbsp;(forall&nbsp;x:X,&nbsp;x&nbsp;&lt;&gt;&nbsp;a&nbsp;-&gt;&nbsp;x&nbsp;&lt;&gt;&nbsp;b&nbsp;-&gt;&nbsp;False))).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;intro&nbsp;Heq;&nbsp;assert&nbsp;(H:&nbsp;discr&nbsp;bool).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;intro&nbsp;H;&nbsp;apply&nbsp;(H&nbsp;true&nbsp;false);&nbsp;destruct&nbsp;x;&nbsp;auto.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;rewrite&nbsp;Heq&nbsp;in&nbsp;H;&nbsp;apply&nbsp;H;&nbsp;clear&nbsp;H.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;destruct&nbsp;a;&nbsp;destruct&nbsp;b&nbsp;as&nbsp;[|n];&nbsp;intro&nbsp;H0;&nbsp;eauto.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;destruct&nbsp;n;&nbsp;[&nbsp;apply&nbsp;(H0&nbsp;2);&nbsp;discriminate&nbsp;|&nbsp;eauto&nbsp;].</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection Is there an axiom-free proof of Streicher's axiom <I>K</I> for
the equality on <TT>nat</TT>?-->

<H4 CLASS="subsubsection"><A NAME="htoc158">137</A>&nbsp;&nbsp;Is there an axiom-free proof of Streicher's axiom <I>K</I> for
the equality on <TT>nat</TT>?</H4><!--SEC END -->

<A NAME="K-nat"></A>
Yes, because equality is decidable on <TT>nat</TT>. Here is the proof.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Eqdep_dec.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Peano_dec.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;K_nat&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;(x:nat)&nbsp;(P:x&nbsp;=&nbsp;x&nbsp;-&gt;&nbsp;Prop),&nbsp;P&nbsp;(refl_equal&nbsp;x)&nbsp;-&gt;&nbsp;forall&nbsp;p:x&nbsp;=&nbsp;x,&nbsp;P&nbsp;p.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros;&nbsp;apply&nbsp;K_dec_set&nbsp;with&nbsp;(p&nbsp;:=&nbsp;p).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;eq_nat_dec.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;assumption.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
</DIV>
<BR>
<BR>
Similarly, we have<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;eq_rect_eq_nat&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;(p:nat)&nbsp;(Q:nat-&gt;Type)&nbsp;(x:Q&nbsp;p)&nbsp;(h:p=p),&nbsp;x&nbsp;=&nbsp;eq_rect&nbsp;p&nbsp;Q&nbsp;x&nbsp;p&nbsp;h.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros;&nbsp;apply&nbsp;K_nat&nbsp;with&nbsp;(p&nbsp;:=&nbsp;h);&nbsp;reflexivity.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection How to prove that two proofs of <TT>n&lt;=m</TT> on <TT>nat</TT> are equal?-->

<H4 CLASS="subsubsection"><A NAME="htoc159">138</A>&nbsp;&nbsp;How to prove that two proofs of <TT>n&lt;=m</TT> on <TT>nat</TT> are equal?</H4><!--SEC END -->

<A NAME="le-uniqueness"></A>
This is provable without requiring any axiom because axiom <I>K</I>
directly holds on <TT>nat</TT>. Here is a proof using question <A HREF="#K-nat">137</A>.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Arith.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Scheme&nbsp;le_ind'&nbsp;:=&nbsp;Induction&nbsp;for&nbsp;le&nbsp;Sort&nbsp;Prop.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;le_uniqueness_proof&nbsp;:&nbsp;forall&nbsp;(n&nbsp;m&nbsp;:&nbsp;nat)&nbsp;(p&nbsp;q&nbsp;:&nbsp;n&nbsp;&lt;=&nbsp;m),&nbsp;p&nbsp;=&nbsp;q.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Proof.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;induction&nbsp;p&nbsp;using&nbsp;le_ind';&nbsp;intro&nbsp;q.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;replace&nbsp;(le_n&nbsp;n)&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;(eq_rect&nbsp;_&nbsp;(fun&nbsp;n0&nbsp;=&gt;&nbsp;n&nbsp;&lt;=&nbsp;n0)&nbsp;(le_n&nbsp;n)&nbsp;_&nbsp;(refl_equal&nbsp;n)).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;2:reflexivity.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;generalize&nbsp;(refl_equal&nbsp;n).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pattern&nbsp;n&nbsp;at&nbsp;2&nbsp;4&nbsp;6&nbsp;10,&nbsp;q;&nbsp;case&nbsp;q;&nbsp;[intro&nbsp;|&nbsp;intros&nbsp;m&nbsp;l&nbsp;e].</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;&lt;-&nbsp;eq_rect_eq_nat;&nbsp;trivial.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contradiction&nbsp;(le_Sn_n&nbsp;m);&nbsp;rewrite&nbsp;&lt;-&nbsp;e;&nbsp;assumption.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;replace&nbsp;(le_S&nbsp;n&nbsp;m&nbsp;p)&nbsp;with</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;(eq_rect&nbsp;_&nbsp;(fun&nbsp;n0&nbsp;=&gt;&nbsp;n&nbsp;&lt;=&nbsp;n0)&nbsp;(le_S&nbsp;n&nbsp;m&nbsp;p)&nbsp;_&nbsp;(refl_equal&nbsp;(S&nbsp;m))).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;2:reflexivity.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;generalize&nbsp;(refl_equal&nbsp;(S&nbsp;m)).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pattern&nbsp;(S&nbsp;m)&nbsp;at&nbsp;1&nbsp;3&nbsp;4&nbsp;6,&nbsp;q;&nbsp;case&nbsp;q;&nbsp;[intro&nbsp;Heq&nbsp;|&nbsp;intros&nbsp;m0&nbsp;l&nbsp;HeqS].</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contradiction&nbsp;(le_Sn_n&nbsp;m);&nbsp;rewrite&nbsp;Heq;&nbsp;assumption.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;injection&nbsp;HeqS;&nbsp;intro&nbsp;Heq;&nbsp;generalize&nbsp;l&nbsp;HeqS.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;&lt;-&nbsp;Heq;&nbsp;intros;&nbsp;rewrite&nbsp;&lt;-&nbsp;eq_rect_eq_nat.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;(IHp&nbsp;l0);&nbsp;reflexivity.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection How to exploit equalities on sets-->

<H4 CLASS="subsubsection"><A NAME="htoc160">139</A>&nbsp;&nbsp;How to exploit equalities on sets</H4><!--SEC END -->

To extract information from an equality on sets, you need to
find a predicate of sets satisfied by the elements of the sets. As an
example, let's consider the following theorem.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Theorem&nbsp;interval_discr&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;m&nbsp;n:nat,</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{x&nbsp;:&nbsp;nat&nbsp;|&nbsp;x&nbsp;&lt;=&nbsp;m}&nbsp;=&nbsp;{x&nbsp;:&nbsp;nat&nbsp;|&nbsp;x&nbsp;&lt;=&nbsp;n}&nbsp;-&gt;&nbsp;m&nbsp;=&nbsp;n.</TT><BR>
</DIV>
<BR>
<BR>
We have a proof requiring the axiom of proof-irrelevance. We
conjecture that proof-irrelevance can be circumvented by introducing a
primitive definition of discrimination of the proofs of
<CODE>{x : nat | x &lt;= m}</CODE>.<BR>
<BR>
<A HREF="./interval_discr.v">Here</A> is the proof.
<BR>
<BR>
<!--TOC subsubsection I have a problem of dependent elimination on
proofs, how to solve it?-->

<H4 CLASS="subsubsection"><A NAME="htoc161">140</A>&nbsp;&nbsp;I have a problem of dependent elimination on
proofs, how to solve it?</H4><!--SEC END -->


<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;Def1&nbsp;:&nbsp;Set&nbsp;:=&nbsp;c1&nbsp;:&nbsp;Def1.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;DefProp&nbsp;:&nbsp;Def1&nbsp;-&gt;&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;c2&nbsp;:&nbsp;forall&nbsp;d:Def1,&nbsp;DefProp&nbsp;d.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;Comb&nbsp;:&nbsp;Set&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;c3&nbsp;:&nbsp;forall&nbsp;d:Def1,&nbsp;DefProp&nbsp;d&nbsp;-&gt;&nbsp;Comb.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;eq_comb&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;(d1&nbsp;d1':Def1)&nbsp;(d2:DefProp&nbsp;d1)&nbsp;(d2':DefProp&nbsp;d1'),</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d1&nbsp;=&nbsp;d1'&nbsp;-&gt;&nbsp;c3&nbsp;d1&nbsp;d2&nbsp;=&nbsp;c3&nbsp;d1'&nbsp;d2'.</TT><BR>
</DIV>
<BR>
<BR>
You need to derive the dependent elimination
scheme for DefProp by hand using <TT>S</TT>cheme.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Scheme&nbsp;DefProp_elim&nbsp;:=&nbsp;Induction&nbsp;for&nbsp;DefProp&nbsp;Sort&nbsp;Prop.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;eq_comb&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;d1&nbsp;d1':Def1,</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d1&nbsp;=&nbsp;d1'&nbsp;-&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(d2:DefProp&nbsp;d1)&nbsp;(d2':DefProp&nbsp;d1'),&nbsp;c3&nbsp;d1&nbsp;d2&nbsp;=&nbsp;c3&nbsp;d1'&nbsp;d2'.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;destruct&nbsp;H.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;destruct&nbsp;d2&nbsp;using&nbsp;DefProp_elim.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;destruct&nbsp;d2'&nbsp;using&nbsp;DefProp_elim.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;reflexivity.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
</DIV>
<BR>
<BR>
<!--TOC subsubsection And what if I want to prove the following?-->

<H4 CLASS="subsubsection"><A NAME="htoc162">141</A>&nbsp;&nbsp;And what if I want to prove the following?</H4><!--SEC END -->


<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;natProp&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;p0&nbsp;:&nbsp;natProp&nbsp;0</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;|&nbsp;pS&nbsp;:&nbsp;forall&nbsp;n:nat,&nbsp;natProp&nbsp;n&nbsp;-&gt;&nbsp;natProp&nbsp;(S&nbsp;n).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Inductive&nbsp;package&nbsp;:&nbsp;Set&nbsp;:=</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;pack&nbsp;:&nbsp;forall&nbsp;n:nat,&nbsp;natProp&nbsp;n&nbsp;-&gt;&nbsp;package.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;eq_pack&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;forall&nbsp;n&nbsp;n':nat,</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;n'&nbsp;-&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(np:natProp&nbsp;n)&nbsp;(np':natProp&nbsp;n'),&nbsp;pack&nbsp;n&nbsp;np&nbsp;=&nbsp;pack&nbsp;n'&nbsp;np'.</TT><BR>
</DIV>
<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Scheme&nbsp;natProp_elim&nbsp;:=&nbsp;Induction&nbsp;for&nbsp;natProp&nbsp;Sort&nbsp;Prop.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Definition&nbsp;pack_S&nbsp;:&nbsp;package&nbsp;-&gt;&nbsp;package.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;destruct&nbsp;1.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;(pack&nbsp;(S&nbsp;n)).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;pS;&nbsp;assumption.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Defined.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Lemma&nbsp;eq_pack&nbsp;:</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;n':nat,</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;n'&nbsp;-&gt;</TT><BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(np:natProp&nbsp;n)&nbsp;(np':natProp&nbsp;n'),&nbsp;pack&nbsp;n&nbsp;np&nbsp;=&nbsp;pack&nbsp;n'&nbsp;np'.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;intros&nbsp;n&nbsp;n'&nbsp;Heq&nbsp;np&nbsp;np'.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;generalize&nbsp;dependent&nbsp;n'.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;induction&nbsp;np&nbsp;using&nbsp;natProp_elim.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;induction&nbsp;np'&nbsp;using&nbsp;natProp_elim;&nbsp;intros;&nbsp;auto.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;discriminate&nbsp;Heq.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;induction&nbsp;np'&nbsp;using&nbsp;natProp_elim;&nbsp;intros;&nbsp;auto.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;&nbsp;discriminate&nbsp;Heq.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;change&nbsp;(pack_S&nbsp;(pack&nbsp;n&nbsp;np)&nbsp;=&nbsp;pack_S&nbsp;(pack&nbsp;n0&nbsp;np')).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;(f_equal&nbsp;(A:=package)).</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;apply&nbsp;IHnp.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;auto.</TT><BR>
<BR>
<TT>Coq&nbsp;&lt;&nbsp;Qed.</TT><BR>
</DIV>
<BR>
<BR>
<!--TOC section Publishing tools-->

<H2 CLASS="section"><A NAME="htoc163">13</A>&nbsp;&nbsp;Publishing tools</H2><!--SEC END -->

<!--TOC subsubsection How can I generate some latex from my development?-->

<H4 CLASS="subsubsection"><A NAME="htoc164">142</A>&nbsp;&nbsp;How can I generate some latex from my development?</H4><!--SEC END -->

You can use <TT>coqdoc</TT>.<BR>
<BR>
<!--TOC subsubsection How can I generate some HTML from my development?-->

<H4 CLASS="subsubsection"><A NAME="htoc165">143</A>&nbsp;&nbsp;How can I generate some HTML from my development?</H4><!--SEC END -->

You can use <TT>coqdoc</TT>.<BR>
<BR>
<!--TOC subsubsection How can I generate some dependency graph from my development?-->

<H4 CLASS="subsubsection"><A NAME="htoc166">144</A>&nbsp;&nbsp;How can I generate some dependency graph from my development?</H4><!--SEC END -->

<!--TOC subsubsection How can I cite some <SPAN STYLE="font-variant:small-caps">Coq</SPAN> in my latex document?-->

<H4 CLASS="subsubsection"><A NAME="htoc167">145</A>&nbsp;&nbsp;How can I cite some <SPAN STYLE="font-variant:small-caps">Coq</SPAN> in my latex document?</H4><!--SEC END -->

You can use <TT>coq_tex</TT>.<BR>
<BR>
<!--TOC subsubsection How can I cite the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> reference manual?-->

<H4 CLASS="subsubsection"><A NAME="htoc168">146</A>&nbsp;&nbsp;How can I cite the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> reference manual?</H4><!--SEC END -->

You can use this bibtex entry:
<PRE CLASS="verbatim">
@Manual{Coq:manual,
  title =        {The Coq proof assistant reference manual},
  author =       {\mbox{The Coq development team}},
  organization = {LogiCal Project},
  note =         {Version 8.0},
  year =         {2004},
  url =          "http://coq.inria.fr"
}
</PRE>
<!--TOC subsubsection Where can I publish my developments in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc169">147</A>&nbsp;&nbsp;Where can I publish my developments in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END -->

You can submit your developments as a user contribution to the <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
development team. This ensures its liveness along the evolution and
possible changes of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.<BR>
<BR>
You can also submit your developments to the HELM/MoWGLI repository at
the University of Bologna (see
<A HREF="http://mowgli.cs.unibo.it"><TT>http://mowgli.cs.unibo.it</TT></A>). For
developments submitted in this database, it is possible to visualize
the developments in natural language and execute various retrieving
requests.<BR>
<BR>
<!--TOC subsubsection How can I read my proof in natural language?-->

<H4 CLASS="subsubsection"><A NAME="htoc170">148</A>&nbsp;&nbsp;How can I read my proof in natural language?</H4><!--SEC END -->

You can submit your proof to the HELM/MoWGLI repository and use the
rendering tool provided by the server (see
<A HREF="http://mowgli.cs.unibo.it"><TT>http://mowgli.cs.unibo.it</TT></A>).<BR>
<BR>
<!--TOC section <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN>-->

<H2 CLASS="section"><A NAME="htoc171">14</A>&nbsp;&nbsp;<SPAN STYLE="font-variant:small-caps">CoqIde</SPAN></H2><!--SEC END -->

<!--TOC subsubsection What is <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN>?-->

<H4 CLASS="subsubsection"><A NAME="htoc172">149</A>&nbsp;&nbsp;What is <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN>?</H4><!--SEC END -->

<SPAN STYLE="font-variant:small-caps">CoqIde</SPAN> is a gtk based GUI for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.<BR>
<BR>
<!--TOC subsubsection How to enable Emacs keybindings?-->

<H4 CLASS="subsubsection"><A NAME="htoc173">150</A>&nbsp;&nbsp;How to enable Emacs keybindings?</H4><!--SEC END -->

 Insert <TT>gtk-key-theme-name = "Emacs"</TT>
 in your <TT>.coqide-gtk2rc</TT> file. It may be in the current dir
 or in <CODE>$HOME</CODE> dir. This is done by default.<BR>
<BR>
<!--TOC subsubsection How to enable antialiased fonts?-->

<H4 CLASS="subsubsection"><A NAME="htoc174">151</A>&nbsp;&nbsp;How to enable antialiased fonts?</H4><!--SEC END -->

Set the <CODE>GDK_USE_XFT</CODE> variable to <CODE>1</CODE>. This is by default with <CODE>Gtk &gt;= 2.2</CODE>.
 If some of your fonts are not available, set <CODE>GDK_USE_XFT</CODE> to <CODE>0</CODE>.<BR>
<BR>
<!--TOC subsubsection How to use those Forall and Exists pretty symbols?-->

<H4 CLASS="subsubsection"><A NAME="htoc175">152</A>&nbsp;&nbsp;How to use those Forall and Exists pretty symbols?</H4><!--SEC END -->
<A NAME="forallcoqide"></A>
 Thanks to the notation features in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, you just need to insert these
lines in your <SPAN STYLE="font-variant:small-caps">Coq</SPAN> buffer:<BR>
<TT>N</TT>otation "&forall; x : t, P" := (forall x:t, P) (at level 200, x ident).
<BR>
<TT>N</TT>otation "&exist; x : t, P" := (exists x:t, P) (at level 200, x ident).
<BR>
<BR>
Copy/Paste of these lines from this file will not work outside of <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN>.
You need to load a file containing these lines or to enter the &forall;
using an input method (see <A HREF="#inputmeth">153</A>). To try it just use <CODE>Require Import utf8</CODE> from inside
<SPAN STYLE="font-variant:small-caps">CoqIde</SPAN>. 
To enable these notations automatically start coqide with
<PRE CLASS="verbatim">
 coqide -l utf8
</PRE>In the ide subdir of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> library, you will find a sample utf8.v with some 
pretty simple notations.<BR>
<BR>
<!--TOC subsubsection How to define an input method for non ASCII symbols?-->

<H4 CLASS="subsubsection"><A NAME="htoc176">153</A>&nbsp;&nbsp;How to define an input method for non ASCII symbols?</H4><!--SEC END -->
<A NAME="inputmeth"></A>
<UL CLASS="itemize"><LI CLASS="li-itemize">
First solution: type <CODE>&lt;CONTROL&gt;&lt;SHIFT&gt;2200</CODE> to enter a forall in the script widow. 
	2200 is the hexadecimal code for forall in unicode charts and is encoded as 	
	in UTF-8.
	2203 is for exists. See <A HREF="http://www.unicode.org"><TT>http://www.unicode.org</TT></A> for more codes.
<LI CLASS="li-itemize">Second solution: rebind <CODE>&lt;AltGr&gt;a</CODE> to forall and <CODE>&lt;AltGr&gt;e</CODE> to exists. 
	Under X11, you need to use something like
<PRE CLASS="verbatim">
  xmodmap -e "keycode  24 = a A F13 F13" 
  xmodmap -e "keycode  26 = e E F14 F14"
</PRE>	and then to add 
<PRE CLASS="verbatim">
  bind "F13" {"insert-at-cursor" ("")}
  bind "F14" {"insert-at-cursor" ("")}
</PRE>	to your "binding "text"" section in <CODE>.coqiderc-gtk2rc.</CODE>
	The strange ("") argument is the UTF-8 encoding for
	0x2200. 
	You can compute these encodings using the lablgtk2 toplevel with 
<PRE CLASS="verbatim">  
Glib.Utf8.from_unichar 0x2200;;
</PRE>	Further symbols can be bound on higher Fxx keys or on even on other keys you
	do not need .
</UL>
<!--TOC subsubsection How to build a custom <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN> with user ml code?-->

<H4 CLASS="subsubsection"><A NAME="htoc177">154</A>&nbsp;&nbsp;How to build a custom <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN> with user ml code?</H4><!--SEC END -->

 Use 
	coqmktop -ide -byte m1.cmo...mi.cmo
 or 
	coqmktop -ide -opt m1.cmx...mi.cmx<BR>
<BR>
<!--TOC subsubsection How to customize the shortcuts for menus?-->

<H4 CLASS="subsubsection"><A NAME="htoc178">155</A>&nbsp;&nbsp;How to customize the shortcuts for menus?</H4><!--SEC END -->

 Two solutions are offered:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Edit $HOME/.coqide.keys by hand or
<LI CLASS="li-itemize">Add "gtk-can-change-accels = 1" in your .coqide-gtk2rc file. Then
 from <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN>, you may select a menu entry and press the desired 
 shortcut. 
</UL>
<!--TOC subsubsection What encoding should I use? What is this \x{iiii} in my file?-->

<H4 CLASS="subsubsection"><A NAME="htoc179">156</A>&nbsp;&nbsp;What encoding should I use? What is this \x{iiii} in my file?</H4><!--SEC END -->

 The encoding option is related to the way files are saved. 
 Keep it as UTF-8 until it becomes important for you to exchange files 
 with non UTF-8 aware applications.
 If you choose something else than UTF-8, then missing characters will 
 be encoded by \x{....} or \x{........}
 where each dot is an hex. digit. 
 The number between braces is the hexadecimal UNICODE index for the
 missing character.<BR>
<BR>
<!--TOC section Extraction-->

<H2 CLASS="section"><A NAME="htoc180">15</A>&nbsp;&nbsp;Extraction</H2><!--SEC END -->

<!--TOC subsubsection What is program extraction?-->

<H4 CLASS="subsubsection"><A NAME="htoc181">157</A>&nbsp;&nbsp;What is program extraction?</H4><!--SEC END -->

Program extraction consist in generating a program from a constructive proof.<BR>
<BR>
<!--TOC subsubsection Which language can I extract to?-->

<H4 CLASS="subsubsection"><A NAME="htoc182">158</A>&nbsp;&nbsp;Which language can I extract to?</H4><!--SEC END -->

You can extract your programs to Objective Caml and Haskell.<BR>
<BR>
<!--TOC subsubsection How can I extract an incomplete proof?-->

<H4 CLASS="subsubsection"><A NAME="htoc183">159</A>&nbsp;&nbsp;How can I extract an incomplete proof?</H4><!--SEC END -->

You can provide programs for your axioms.<BR>
<BR>
<!--TOC section Glossary-->

<H2 CLASS="section"><A NAME="htoc184">16</A>&nbsp;&nbsp;Glossary</H2><!--SEC END -->

<!--TOC subsubsection Can you explain me what an evaluable constant is?-->

<H4 CLASS="subsubsection"><A NAME="htoc185">160</A>&nbsp;&nbsp;Can you explain me what an evaluable constant is?</H4><!--SEC END -->

An evaluable constant is a constant which is unfoldable.<BR>
<BR>
<!--TOC subsubsection What is a goal?-->

<H4 CLASS="subsubsection"><A NAME="htoc186">161</A>&nbsp;&nbsp;What is a goal?</H4><!--SEC END -->

The goal is the statement to be proved.<BR>
<BR>
<!--TOC subsubsection What is a meta variable?-->

<H4 CLASS="subsubsection"><A NAME="htoc187">162</A>&nbsp;&nbsp;What is a meta variable?</H4><!--SEC END -->

A meta variable in <SPAN STYLE="font-variant:small-caps">Coq</SPAN> represents a &#8220;hole&#8221;, i.e. a part of a proof
that is still unknown. <BR>
<BR>
<!--TOC subsubsection What is Gallina?-->

<H4 CLASS="subsubsection"><A NAME="htoc188">163</A>&nbsp;&nbsp;What is Gallina?</H4><!--SEC END -->
 
Gallina is the specification language of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. Complete documentation
of this language can be found in the Reference Manual.<BR>
<BR>
<!--TOC subsubsection What is The Vernacular?-->

<H4 CLASS="subsubsection"><A NAME="htoc189">164</A>&nbsp;&nbsp;What is The Vernacular?</H4><!--SEC END -->
 
It is the language of commands of Gallina i.e. definitions, lemmas, ... <BR>
<BR>
<!--TOC subsubsection What is a dependent type?-->

<H4 CLASS="subsubsection"><A NAME="htoc190">165</A>&nbsp;&nbsp;What is a dependent type?</H4><!--SEC END -->

A dependant type is a type which depends on some term. For instance
&#8220;vector of size n&#8221; is a dependant type representing all the vectors
of size <I>n</I>. Its type depends on <I>n</I><BR>
<BR>
<!--TOC subsubsection What is a proof by reflection?-->

<H4 CLASS="subsubsection"><A NAME="htoc191">166</A>&nbsp;&nbsp;What is a proof by reflection?</H4><!--SEC END -->

This is a proof generated by some computation which is done using the
internal reduction of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> (not using the tactic language of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
(<SPAN STYLE="font-variant:small-caps">Ltac</SPAN>) nor the implementation language for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>). An example of
tactic using the reflection mechanism is the <TT>ring</TT> tactic. The
reflection method consist in reflecting a subset of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> language (for
example the arithmetical expressions) into an object of the <SPAN STYLE="font-variant:small-caps">Coq</SPAN>language itself (in this case an inductive type denoting arithmetical
expressions). For more information see&nbsp;[<A HREF="#howe"><CITE>14</CITE></A><CITE>, </CITE><A HREF="#harrison"><CITE>12</CITE></A><CITE>, </CITE><A HREF="#boutin"><CITE>3</CITE></A>]
and the last chapter of the Coq'Art.<BR>
<BR>
<!--TOC subsubsection What is intuitionistic logic?-->

<H4 CLASS="subsubsection"><A NAME="htoc192">167</A>&nbsp;&nbsp;What is intuitionistic logic?</H4><!--SEC END -->

This is any logic which does not assume that &#8220;A or not A&#8221;.<BR>
<BR>
<!--TOC subsubsection What is proof-irrelevance?-->

<H4 CLASS="subsubsection"><A NAME="htoc193">168</A>&nbsp;&nbsp;What is proof-irrelevance?</H4><!--SEC END -->

See question <A HREF="#proof-irrelevance">33</A><BR>
<BR>
<!--TOC subsubsection What is the difference between opaque and transparent?-->

<H4 CLASS="subsubsection"><A NAME="htoc194">169</A>&nbsp;&nbsp;What is the difference between opaque and transparent?</H4><!--SEC END -->
<A NAME="opaque"></A>	<BR>
<BR>
Opaque definitions can not be unfolded but transparent ones can.<BR>
<BR>
<!--TOC section Troubleshooting-->

<H2 CLASS="section"><A NAME="htoc195">17</A>&nbsp;&nbsp;Troubleshooting</H2><!--SEC END -->

<!--TOC subsubsection What can I do when <TT>Qed.</TT> is slow?-->

<H4 CLASS="subsubsection"><A NAME="htoc196">170</A>&nbsp;&nbsp;What can I do when <TT>Qed.</TT> is slow?</H4><!--SEC END -->

Sometime you can use the <TT>abstract</TT> tactic, which makes as if you had
stated some local lemma, this speeds up the typing process.<BR>
<BR>
<!--TOC subsubsection Why <TT>Reset Initial.</TT> does not work when using <TT>coqc</TT>?-->

<H4 CLASS="subsubsection"><A NAME="htoc197">171</A>&nbsp;&nbsp;Why <TT>Reset Initial.</TT> does not work when using <TT>coqc</TT>?</H4><!--SEC END -->

The initial state corresponds to the state of coqtop when the interactive
session began. It does not make sense in files to compile.<BR>
<BR>
<!--TOC subsubsection What can I do if I get &#8220;No more subgoals but non-instantiated existential variables&#8221;?-->

<H4 CLASS="subsubsection"><A NAME="htoc198">172</A>&nbsp;&nbsp;What can I do if I get &#8220;No more subgoals but non-instantiated existential variables&#8221;?</H4><!--SEC END -->

This means that <TT>eauto</TT> or <TT>eapply</TT> didn't instantiate an
existential variable which eventually got erased by some computation.
You have to backtrack to the faulty occurrence of <TT>eauto</TT> or
<TT>eapply</TT> and give the missing argument an explicit value.<BR>
<BR>
<!--TOC subsubsection What can I do if I get &#8220;Cannot solve a second-order unification problem&#8221;?-->

<H4 CLASS="subsubsection"><A NAME="htoc199">173</A>&nbsp;&nbsp;What can I do if I get &#8220;Cannot solve a second-order unification problem&#8221;?</H4><!--SEC END -->

You can help <SPAN STYLE="font-variant:small-caps">Coq</SPAN> using the <TT>pattern</TT> tactic.<BR>
<BR>
<!--TOC subsubsection Why does <SPAN STYLE="font-variant:small-caps">Coq</SPAN> tell me that <TT>{x:A|(P x)}</TT> is not convertible with <TT>(sig A P)</TT>?-->

<H4 CLASS="subsubsection"><A NAME="htoc200">174</A>&nbsp;&nbsp;Why does <SPAN STYLE="font-variant:small-caps">Coq</SPAN> tell me that <TT>{x:A|(P x)}</TT> is not convertible with <TT>(sig A P)</TT>?</H4><!--SEC END -->

This is because <TT>{x:A|P x}</TT> is a notation for
<TT>sig (fun x:A =&gt; P x)</TT>. Since <SPAN STYLE="font-variant:small-caps">Coq</SPAN> does not reason up to
&eta;-conversion, this is different from <TT>sig P</TT>.<BR>
<BR>
<!--TOC subsubsection I copy-paste a term and <SPAN STYLE="font-variant:small-caps">Coq</SPAN> says it is not convertible
 to the original term. Sometimes it even says the copied term is not
well-typed.-->

<H4 CLASS="subsubsection"><A NAME="htoc201">175</A>&nbsp;&nbsp;I copy-paste a term and <SPAN STYLE="font-variant:small-caps">Coq</SPAN> says it is not convertible
 to the original term. Sometimes it even says the copied term is not
well-typed.</H4><!--SEC END -->

This is probably due to invisible implicit information (implicit
arguments, coercions and Cases annotations) in the printed term, which
is not re-synthesised from the copied-pasted term in the same way as
it is in the original term.<BR>
<BR>
Consider for instance <TT>(@eq Type True True)</TT>. This term is
printed as <TT>True=True</TT> and re-parsed as <TT>(@eq Prop True
True)</TT>. The two terms are not convertible (hence they fool tactics
like <TT>pattern</TT>).<BR>
<BR>
There is currently no satisfactory answer to the problem. However,
the command <TT>Set Printing All</TT> is useful for diagnosing the
problem.<BR>
<BR>
Due to coercions, one may even face type-checking errors. In some
rare cases, the criterion to hide coercions is a bit too loose, which
may result in a typing error message if the parser is not able to find
again the missing coercion.<BR>
<BR>
<!--TOC section Conclusion and Farewell.-->

<H2 CLASS="section"><A NAME="htoc202">18</A>&nbsp;&nbsp;Conclusion and Farewell.</H2><!--SEC END -->

<A NAME="ccl"></A>
<!--TOC subsubsection What if my question isn't answered here?-->

<H4 CLASS="subsubsection"><A NAME="htoc203">176</A>&nbsp;&nbsp;What if my question isn't answered here?</H4><!--SEC END -->
 
<A NAME="lastquestion"></A>
Don't panic <CODE>:-)</CODE>. You can try the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> manual&nbsp;[<A HREF="#Coq:manual"><CITE>17</CITE></A>] for a technical
description of the prover. The Coq'Art&nbsp;[<A HREF="#Coq:coqart"><CITE>2</CITE></A>] is the first
book written on <SPAN STYLE="font-variant:small-caps">Coq</SPAN> and provides a comprehensive review of the
theorem prover as well as a number of example and exercises. Finally,
the tutorial&nbsp;[<A HREF="#Coq:Tutorial"><CITE>15</CITE></A>] provides a smooth introduction to
theorem proving in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.<BR>
<BR>


<!--TOC section References-->

<H2 CLASS="section">References</H2><!--SEC END -->
<DL CLASS="list" COMPACT="compact"><DT CLASS="dt-list"><A NAME="coqart"><FONT COLOR=purple>[1]</FONT></A><DD CLASS="dd-list">
Yves bertot and Pierre Castéran.
<EM>Coq'Art</EM>.
Springer-Verlag, 2004.
To appear.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="Coq:coqart"><FONT COLOR=purple>[2]</FONT></A><DD CLASS="dd-list">
Yves Bertot and Pierre Castéran.
<EM>Interactive Theorem Proving and Program Development, Coq'Art:
 The Calculus of Inductive Constructions</EM>.
Texts in Theoretical Computer Science. An EATCS series. Springer
 Verlag, 2004.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="boutin"><FONT COLOR=purple>[3]</FONT></A><DD CLASS="dd-list">
Samuel Boutin.
Using reflection to build efficient and certified decision pro
 cedures.
In M.&nbsp;Abadi and T.&nbsp;Ito, editors, <EM>Proceedings of TACS'97</EM>, volume
 1281 of <EM>LNCS</EM>. Springer-Verlag, 1997.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="LaTeX:symb"><FONT COLOR=purple>[4]</FONT></A><DD CLASS="dd-list">
David Carlisle, Scott Pakin, and Alexander Holt.
<EM>The Great, Big List of L<sup>A</sup>T<sub>E</sub>X Symbols</EM>, February 2001.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="Coq85"><FONT COLOR=purple>[5]</FONT></A><DD CLASS="dd-list">
Thierry Coquand.
<EM>Une Théorie des Constructions</EM>.
PhD thesis, Université Paris&nbsp;7, January 1985.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="CoHu86"><FONT COLOR=purple>[6]</FONT></A><DD CLASS="dd-list">
Thierry Coquand and Gérard Huet.
The Calculus of Constructions.
<EM>Information and Computation</EM>, 76(2/3), 1988.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="CoPa89"><FONT COLOR=purple>[7]</FONT></A><DD CLASS="dd-list">
Thierry Coquand and Christine Paulin-Mohring.
Inductively defined types.
In P.&nbsp;Martin-Löf and G.&nbsp;Mints, editors, <EM>Proceedings of
 Colog'88</EM>, volume 417 of <EM>Lecture Notes in Computer Science</EM>.
 Springer-Verlag, 1990.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="Types:Dowek"><FONT COLOR=purple>[8]</FONT></A><DD CLASS="dd-list">
Gilles Dowek.
Théorie des types.
Lecture notes, 2002.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="EGThese"><FONT COLOR=purple>[9]</FONT></A><DD CLASS="dd-list">
Eduardo Giménez.
<EM>Un Calcul de Constructions Infinies et son application a la
 vérification de systèmes communicants</EM>.
thèse d'université, Ecole Normale Supérieure de Lyon, December 1996.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="Gir70"><FONT COLOR=purple>[10]</FONT></A><DD CLASS="dd-list">
Jean-Yves Girard.
Une extension de l'interprétation de Gödel à l'analyse, et
 son application à l'élimination des coupures dans l'analyse et la
 théorie des types.
In <EM>Proceedings of the 2nd Scandinavian Logic Symposium</EM>.
 North-Holland, 1970.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="ProofsTypes"><FONT COLOR=purple>[11]</FONT></A><DD CLASS="dd-list">
Jean-Yves Girard, Yves Lafont, and Paul Taylor.
<EM>Proofs and Types</EM>.
Cambrige Tracts in Theoretical Computer Science, Cambridge University
 Press, 1989.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="harrison"><FONT COLOR=purple>[12]</FONT></A><DD CLASS="dd-list">
John Harrison.
Meta theory and reflection in theorem proving:a survey and cri tique.
Technical Report CRC-053, SRI International Cambridge Computer
 Science Research Center, 1995.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="HofStr98"><FONT COLOR=purple>[13]</FONT></A><DD CLASS="dd-list">
Martin Hofmann and Thomas Streicher.
The groupoid interpretation of type theory.
In <EM>Proceedings of the meeting Twenty-five years of constructive
 type theory</EM>. Oxford University Press, 1998.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="howe"><FONT COLOR=purple>[14]</FONT></A><DD CLASS="dd-list">
Doug Howe.
Computation meta theory in nuprl.
In E.&nbsp;Lusk and R.&nbsp;Overbeek, editors, <EM>The Proceedings of the
 Ninth International Conference of Autom ated Deduction</EM>, volume 310, pages
 238&ndash;257. Springer-Verlag, 1988.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="Coq:Tutorial"><FONT COLOR=purple>[15]</FONT></A><DD CLASS="dd-list">
Gérard Huet, Gilles Kahn, and Christine Paulin-Mohring.
<EM>The Coq Proof Assistant A Tutorial</EM>, 2004.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="Luo90"><FONT COLOR=purple>[16]</FONT></A><DD CLASS="dd-list">
Z.&nbsp;Luo.
<EM>An Extended Calculus of Constructions</EM>.
PhD thesis, University of Edinburgh, 1990.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="Coq:manual"><FONT COLOR=purple>[17]</FONT></A><DD CLASS="dd-list">
The Coq development team.
<EM>The Coq proof assistant reference manual</EM>.
LogiCal Project, 2004.
Version 8.0.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="LaTeX:intro"><FONT COLOR=purple>[18]</FONT></A><DD CLASS="dd-list">
Tobias Oetiker.
<EM>The Not So Short Introduction to L<sup>A</sup>T<sub>E</sub>X2e</EM>, January 1999.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="Pau96b"><FONT COLOR=purple>[19]</FONT></A><DD CLASS="dd-list">
Christine Paulin-Mohring.
<EM>Définitions Inductives en Théorie des Types d'Ordre Supérieur</EM>.
Habilitation à diriger les recherches, Université Claude Bernard Lyon
 I, December 1996.</DL>





<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://pauillac.inria.fr/~maranget/hevea/index.html"><EM>H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</EM></A><EM>.</EM></BLOCKQUOTE>
</BODY>